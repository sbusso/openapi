{
  "swagger": "2.0",
  "info": {
    "description": "Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.\nExamples are available at https://documentation.portainer.io/api/api-examples/\nYou can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).\n\n# Authentication\n\nMost of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.\nPortainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request\nwith the **Bearer** authentication mechanism.\n\nExample:\n\n```\nBearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE\n```\n\n# Security\n\nEach API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).\n\nDifferent access policies are available:\n\n- Public access\n- Authenticated access\n- Restricted access\n- Administrator access\n\n### Public access\n\nNo authentication is required to access the environments(endpoints) with this access policy.\n\n### Authenticated access\n\nAuthentication is required to access the environments(endpoints) with this access policy.\n\n### Restricted access\n\nAuthentication is required to access the environments(endpoints) with this access policy.\nExtra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.\n\n### Administrator access\n\nAuthentication as well as an administrator role are required to access the environments(endpoints) with this access policy.\n\n# Execute Docker requests\n\nPortainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).\n\nInstead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.\n\nTo do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).\n\n# Private Registry\n\nUsing private registry, you will need to pass a based64 encoded JSON string ‘{\"registryId\":\\<registryID value\\>}’ inside the Request Header. The parameter name is \"X-Registry-Auth\".\n\\<registryID value\\> - The registry ID where the repository was created.\n\nExample:\n\n```\neyJyZWdpc3RyeUlkIjoxfQ==\n```\n\n**NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).\n",
    "version": "2.27.1",
    "title": "PortainerCE API",
    "contact": {
      "email": "info@portainer.io"
    },
    "license": {
      "name": "zlib",
      "url": "https://github.com/portainer/portainer/blob/develop/LICENSE"
    }
  },
  "basePath": "/api",
  "tags": [
    {
      "name": "auth",
      "description": "Authenticate against Portainer HTTP API"
    },
    {
      "name": "backup",
      "description": "Manage backups"
    },
    {
      "name": "custom_templates",
      "description": "Manage Custom Templates"
    },
    {
      "name": "docker",
      "description": "Manage Docker resources"
    },
    {
      "name": "edge",
      "description": "Manage Edge related environment(endpoint) settings"
    },
    {
      "name": "edge_groups",
      "description": "Manage Edge Groups"
    },
    {
      "name": "edge_jobs",
      "description": "Manage Edge Jobs"
    },
    {
      "name": "edge_stacks",
      "description": "Manage Edge Stacks"
    },
    {
      "name": "edge_templates",
      "description": "Manage Edge Templates"
    },
    {
      "name": "endpoint_groups",
      "description": "Manage environment(endpoint) groups"
    },
    {
      "name": "endpoints",
      "description": "Manage Docker environments(endpoints)"
    },
    {
      "name": "gitops",
      "description": "Operate git repository"
    },
    {
      "name": "helm",
      "description": "Manage Helm charts"
    },
    {
      "name": "intel",
      "description": "Manage Intel AMT settings"
    },
    {
      "name": "kubernetes",
      "description": "Manage Kubernetes cluster"
    },
    {
      "name": "ldap",
      "description": "Manage LDAP settings"
    },
    {
      "name": "motd",
      "description": "Fetch the message of the day"
    },
    {
      "name": "registries",
      "description": "Manage Docker registries"
    },
    {
      "name": "resource_controls",
      "description": "Manage access control on Docker resources"
    },
    {
      "name": "roles",
      "description": "Manage roles"
    },
    {
      "name": "settings",
      "description": "Manage Portainer settings"
    },
    {
      "name": "ssl",
      "description": "Manage ssl settings"
    },
    {
      "name": "stacks",
      "description": "Manage stacks"
    },
    {
      "name": "status",
      "description": "Information about the Portainer instance"
    },
    {
      "name": "system",
      "description": "Manage Portainer system"
    },
    {
      "name": "tags",
      "description": "Manage tags"
    },
    {
      "name": "team_memberships",
      "description": "Manage team memberships"
    },
    {
      "name": "teams",
      "description": "Manage teams"
    },
    {
      "name": "templates",
      "description": "Manage App Templates"
    },
    {
      "name": "upload",
      "description": "Upload files"
    },
    {
      "name": "users",
      "description": "Manage users"
    },
    {
      "name": "webhooks",
      "description": "Manage webhooks"
    },
    {
      "name": "websocket",
      "description": "Create exec sessions using websockets"
    }
  ],
  "schemes": [
    "http",
    "https"
  ],
  "paths": {
    "/auth": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Authenticate",
        "description": "**Access policy**: public\nUse this environment(endpoint) to authenticate against Portainer using a username and password.",
        "operationId": "AuthenticateUser",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Credentials used for authentication",
            "required": true,
            "schema": {
              "$ref": "#/definitions/auth.authenticatePayload"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/auth.authenticateResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "422": {
            "description": "Invalid Credentials"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/auth/logout": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Logout",
        "description": "**Access policy**: public",
        "operationId": "Logout",
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/auth/oauth/validate": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Authenticate with OAuth",
        "description": "**Access policy**: public",
        "operationId": "ValidateOAuth",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "OAuth Credentials used for authentication",
            "required": true,
            "schema": {
              "$ref": "#/definitions/auth.oauthPayload"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/auth.authenticateResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "422": {
            "description": "Invalid Credentials"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/backup": {
      "post": {
        "tags": [
          "backup"
        ],
        "summary": "Creates an archive with a system data snapshot that could be used to restore the system.",
        "description": "Creates an archive with a system data snapshot that could be used to restore the system.\n**Access policy**: admin",
        "operationId": "Backup",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/octet-stream"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "An object contains the password to encrypt the backup with",
            "required": false,
            "schema": {
              "$ref": "#/definitions/backup.backupPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates": {
      "get": {
        "tags": [
          "custom_templates"
        ],
        "summary": "List available custom templates",
        "description": "List available custom templates.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Template types",
            "required": true,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "edge",
            "in": "query",
            "description": "Filter by edge templates",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.CustomTemplate"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/{id}": {
      "get": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Inspect a custom template",
        "description": "Retrieve details about a template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.CustomTemplate"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Template not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Update a template",
        "description": "Update a template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Template details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/customtemplates.customTemplateUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.CustomTemplate"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access template"
          },
          "404": {
            "description": "Template not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Remove a template",
        "description": "Remove a template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Access denied to resource"
          },
          "404": {
            "description": "Template not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/{id}/file": {
      "get": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Get Template stack file content.",
        "description": "Retrieve the content of the Stack file for the specified custom template\n**Access policy**: authenticated",
        "operationId": "CustomTemplateFile",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/customtemplates.fileResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Custom template not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/{id}/git_fetch": {
      "put": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Fetch the latest config file content based on custom template's git repository configuration",
        "description": "Retrieve details about a template created from git repository method.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateGitFetch",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/customtemplates.fileResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Custom template not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/create/file": {
      "post": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Create a custom template",
        "description": "Create a custom template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateCreateFile",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "Title",
            "in": "formData",
            "description": "Title of the template",
            "required": true,
            "type": "string"
          },
          {
            "name": "Description",
            "in": "formData",
            "description": "Description of the template",
            "required": true,
            "type": "string"
          },
          {
            "name": "Note",
            "in": "formData",
            "description": "A note that will be displayed in the UI. Supports HTML content",
            "required": true,
            "type": "string"
          },
          {
            "name": "Platform",
            "in": "formData",
            "description": "Platform associated to the template (1 - 'linux', 2 - 'windows')",
            "required": true,
            "type": "integer",
            "enum": [
              1,
              2
            ]
          },
          {
            "name": "Type",
            "in": "formData",
            "description": "Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)",
            "required": true,
            "type": "integer",
            "enum": [
              1,
              2,
              3
            ]
          },
          {
            "name": "File",
            "in": "formData",
            "description": "File",
            "required": true,
            "type": "file"
          },
          {
            "name": "Logo",
            "in": "formData",
            "description": "URL of the template's logo",
            "required": false,
            "type": "string"
          },
          {
            "name": "Variables",
            "in": "formData",
            "description": "A json array of variables definitions",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.CustomTemplate"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/create/repository": {
      "post": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Create a custom template",
        "description": "Create a custom template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateCreateRepository",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Required when using method=repository",
            "required": true,
            "schema": {
              "$ref": "#/definitions/customtemplates.customTemplateFromGitRepositoryPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.CustomTemplate"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/custom_templates/create/string": {
      "post": {
        "tags": [
          "custom_templates"
        ],
        "summary": "Create a custom template",
        "description": "Create a custom template.\n**Access policy**: authenticated",
        "operationId": "CustomTemplateCreateString",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/customtemplates.customTemplateFromFileContentPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.CustomTemplate"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/docker/{environmentId}/containers/{containerId}/gpus": {
      "get": {
        "tags": [
          "docker"
        ],
        "summary": "Fetch container gpus data",
        "description": "**Access policy**:",
        "operationId": "dockerContainerGpusInspect",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "environmentId",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "containerId",
            "in": "path",
            "description": "Container identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/containers.containerGpusResponse"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "404": {
            "description": "Environment or container not found"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/docker/{environmentId}/dashboard": {
      "post": {
        "tags": [
          "docker"
        ],
        "summary": "Get counters for the dashboard",
        "description": "**Access policy**: restricted",
        "operationId": "dockerDashboard",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "environmentId",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/docker.dashboardResponse"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/docker/{environmentId}/images": {
      "get": {
        "tags": [
          "docker"
        ],
        "summary": "Fetch images",
        "description": "**Access policy**:",
        "operationId": "dockerImagesList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "environmentId",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "withUsage",
            "in": "query",
            "description": "Include image usage information",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/images.ImageResponse"
              }
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal server error"
          }
        }
      }
    },
    "/edge_groups": {
      "get": {
        "tags": [
          "edge_groups"
        ],
        "summary": "list EdgeGroups",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeGroupList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "EdgeGroups",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/edgegroups.decoratedEdgeGroup"
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "post": {
        "tags": [
          "edge_groups"
        ],
        "summary": "Create an EdgeGroup",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeGroupCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "EdgeGroup data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgegroups.edgeGroupCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeGroup"
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_groups/{id}": {
      "get": {
        "tags": [
          "edge_groups"
        ],
        "summary": "Inspects an EdgeGroup",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeGroupInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeGroup Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeGroup"
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "put": {
        "tags": [
          "edge_groups"
        ],
        "summary": "Updates an EdgeGroup",
        "description": "**Access policy**: administrator",
        "operationId": "EgeGroupUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeGroup Id",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "EdgeGroup data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgegroups.edgeGroupUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeGroup"
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "delete": {
        "tags": [
          "edge_groups"
        ],
        "summary": "Deletes an EdgeGroup",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeGroupDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeGroup Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "409": {
            "description": "Edge group is in use by an Edge stack or Edge job"
          },
          "500": {
            "description": "Server error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs": {
      "get": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Fetch EdgeJobs list",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.EdgeJob"
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/{id}": {
      "get": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Inspect an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeJob"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "put": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Update an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "EdgeGroup data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgejobs.edgeJobUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeJob"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "delete": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Delete an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/{id}/file": {
      "get": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Fetch a file of an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobFile",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/edgejobs.edgeJobFileResponse"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/{id}/tasks": {
      "get": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Fetch the list of tasks on an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobTasksList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/edgejobs.taskContainer"
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/{id}/tasks/{taskID}/logs": {
      "get": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Fetch the log for a specifc task on an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobTaskLogsInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          },
          {
            "name": "taskID",
            "in": "path",
            "description": "Task Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/edgejobs.fileResponse"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "post": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Collect the log for a specifc task on an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobTasksCollect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          },
          {
            "name": "taskID",
            "in": "path",
            "description": "Task Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "delete": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Clear the log for a specifc task on an EdgeJob",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobTasksClear",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeJob Id",
            "required": true,
            "type": "integer"
          },
          {
            "name": "taskID",
            "in": "path",
            "description": "Task Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/create/file": {
      "post": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Create an EdgeJob from a file",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobCreateFile",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "file",
            "in": "formData",
            "description": "Content of the Stack file",
            "required": true,
            "type": "file"
          },
          {
            "name": "Name",
            "in": "formData",
            "description": "Name of the stack",
            "required": true,
            "type": "string"
          },
          {
            "name": "CronExpression",
            "in": "formData",
            "description": "A cron expression to schedule this job",
            "required": true,
            "type": "string"
          },
          {
            "name": "EdgeGroups",
            "in": "formData",
            "description": "JSON stringified array of Edge Groups ids",
            "required": true,
            "type": "string"
          },
          {
            "name": "Endpoints",
            "in": "formData",
            "description": "JSON stringified array of Environment ids",
            "required": true,
            "type": "string"
          },
          {
            "name": "Recurring",
            "in": "formData",
            "description": "If recurring",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeGroup"
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_jobs/create/string": {
      "post": {
        "tags": [
          "edge_jobs"
        ],
        "summary": "Create an EdgeJob from a text",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeJobCreateString",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "EdgeGroup data when method is string",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgejobs.edgeJobCreateFromFileContentPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeGroup"
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks": {
      "get": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Fetches the list of EdgeStacks",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.EdgeStack"
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks/{id}": {
      "get": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Inspect an EdgeStack",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "put": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Update an EdgeStack",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "EdgeStack data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgestacks.updateEdgeStackPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      },
      "delete": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Delete an EdgeStack",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks/{id}/file": {
      "get": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Fetches the stack file for an EdgeStack",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackFile",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/edgestacks.stackFileResponse"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks/{id}/status": {
      "put": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Update an EdgeStack status",
        "description": "Authorized only if the request is done by an Edge Environment(Endpoint)",
        "operationId": "EdgeStackStatusUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "EdgeStack status payload",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgestacks.updateStatusPayload"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/edge_stacks/create/file": {
      "post": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Create an EdgeStack from file",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackCreateFile",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "Name",
            "in": "formData",
            "description": "Name of the stack. it must only consist of lowercase alphanumeric characters, hyphens, or underscores as well as start with a letter or number",
            "required": true,
            "type": "string"
          },
          {
            "name": "file",
            "in": "formData",
            "description": "Content of the Stack file",
            "required": true,
            "type": "file"
          },
          {
            "name": "EdgeGroups",
            "in": "formData",
            "description": "JSON stringified array of Edge Groups ids",
            "required": true,
            "type": "string"
          },
          {
            "name": "DeploymentType",
            "in": "formData",
            "description": "deploy type 0 - 'compose', 1 - 'kubernetes'",
            "required": true,
            "type": "integer"
          },
          {
            "name": "Registries",
            "in": "formData",
            "description": "JSON stringified array of Registry ids to use for this stack",
            "required": false,
            "type": "string"
          },
          {
            "name": "UseManifestNamespaces",
            "in": "formData",
            "description": "Uses the manifest's namespaces instead of the default one, relevant only for kube environments",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "PrePullImage",
            "in": "formData",
            "description": "Pre Pull image",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "RetryDeploy",
            "in": "formData",
            "description": "Retry deploy",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "dryrun",
            "in": "query",
            "description": "if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks/create/repository": {
      "post": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Create an EdgeStack from a git repository",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackCreateRepository",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgestacks.edgeStackFromGitRepositoryPayload"
            }
          },
          {
            "name": "dryrun",
            "in": "query",
            "description": "if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/edge_stacks/create/string": {
      "post": {
        "tags": [
          "edge_stacks"
        ],
        "summary": "Create an EdgeStack from a text",
        "description": "**Access policy**: administrator",
        "operationId": "EdgeStackCreateString",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/edgestacks.edgeStackFromStringPayload"
            }
          },
          {
            "name": "dryrun",
            "in": "query",
            "description": "if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.EdgeStack"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "500": {
            "description": "Internal server error"
          },
          "503": {
            "description": "Edge compute features are disabled"
          }
        }
      }
    },
    "/endpoint_groups": {
      "get": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "List Environment(Endpoint) groups",
        "description": "List all environment(endpoint) groups based on the current user authorizations. Will\nreturn all environment(endpoint) groups if using an administrator account otherwise it will\nonly return authorized environment(endpoint) groups.\n**Access policy**: restricted",
        "operationId": "EndpointGroupList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Environment(Endpoint) group",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.EndpointGroup"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Create an Environment(Endpoint) Group",
        "description": "Create a new environment(endpoint) group.\n**Access policy**: administrator",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Environment(Endpoint) Group details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpointgroups.endpointGroupCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.EndpointGroup"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoint_groups/{id}": {
      "get": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Inspect an Environment(Endpoint) group",
        "description": "Retrieve details abont an environment(endpoint) group.\n**Access policy**: administrator",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) group identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.EndpointGroup"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "EndpointGroup not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Update an environment(endpoint) group",
        "description": "Update an environment(endpoint) group.\n**Access policy**: administrator",
        "operationId": "EndpointGroupUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EndpointGroup identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "EndpointGroup details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpointgroups.endpointGroupUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.EndpointGroup"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "EndpointGroup not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Remove an environment(endpoint) group",
        "description": "Remove an environment(endpoint) group.\n**Access policy**: administrator",
        "operationId": "EndpointGroupDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EndpointGroup identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "EndpointGroup not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoint_groups/{id}/endpoints/{endpointId}": {
      "put": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Add an environment(endpoint) to an environment(endpoint) group",
        "description": "Add an environment(endpoint) to an environment(endpoint) group\n**Access policy**: administrator",
        "operationId": "EndpointGroupAddEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EndpointGroup identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "EndpointGroup not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "endpoint_groups"
        ],
        "summary": "Removes environment(endpoint) from an environment(endpoint) group",
        "description": "**Access policy**: administrator",
        "operationId": "EndpointGroupDeleteEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "EndpointGroup identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "EndpointGroup not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints": {
      "get": {
        "tags": [
          "endpoints"
        ],
        "summary": "List environments(endpoints)",
        "description": "List all environments(endpoints) based on the current user authorizations. Will\nreturn all environments(endpoints) if using an administrator or team leader account otherwise it will\nonly return authorized environments(endpoints).\n**Access policy**: restricted",
        "operationId": "EndpointList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "start",
            "in": "query",
            "description": "Start searching from",
            "required": false,
            "type": "integer"
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limit results to this value",
            "required": false,
            "type": "integer"
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order sorted results by desc/asc",
            "required": false,
            "type": "integer"
          },
          {
            "name": "search",
            "in": "query",
            "description": "Search query",
            "required": false,
            "type": "string"
          },
          {
            "name": "groupIds",
            "in": "query",
            "description": "List environments(endpoints) of these groups",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "status",
            "in": "query",
            "description": "List environments(endpoints) by this status",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "types",
            "in": "query",
            "description": "List environments(endpoints) of this type",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "tagIds",
            "in": "query",
            "description": "search environments(endpoints) with these tags (depends on tagsPartialMatch)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "tagsPartialMatch",
            "in": "query",
            "description": "If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "endpointIds",
            "in": "query",
            "description": "will return only these environments(endpoints)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "provisioned",
            "in": "query",
            "description": "If true, will return environment(endpoint) that were provisioned",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "agentVersions",
            "in": "query",
            "description": "will return only environments with on of these agent versions",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "edgeAsync",
            "in": "query",
            "description": "if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "edgeDeviceUntrusted",
            "in": "query",
            "description": "if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "edgeCheckInPassedSeconds",
            "in": "query",
            "description": "if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)",
            "required": false,
            "type": "number"
          },
          {
            "name": "excludeSnapshots",
            "in": "query",
            "description": "if true, the snapshot data won't be retrieved",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "name",
            "in": "query",
            "description": "will return only environments(endpoints) with this name",
            "required": false,
            "type": "string"
          },
          {
            "name": "edgeStackStatus",
            "in": "query",
            "description": "only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Endpoints",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Endpoint"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Create a new environment(endpoint)",
        "description": "Create a new environment(endpoint) that will be used to manage an environment(endpoint).\n**Access policy**: administrator",
        "operationId": "EndpointCreate",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "Name",
            "in": "formData",
            "description": "Name that will be used to identify this environment(endpoint) (example: my-environment)",
            "required": true,
            "type": "string"
          },
          {
            "name": "EndpointCreationType",
            "in": "formData",
            "description": "Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)",
            "required": true,
            "type": "integer"
          },
          {
            "name": "ContainerEngine",
            "in": "formData",
            "description": "Container engine used by the environment(endpoint). Value must be one of: 'docker' or 'podman'",
            "required": false,
            "type": "string"
          },
          {
            "name": "URL",
            "in": "formData",
            "description": "URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)",
            "required": false,
            "type": "string"
          },
          {
            "name": "PublicURL",
            "in": "formData",
            "description": "URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)",
            "required": false,
            "type": "string"
          },
          {
            "name": "GroupID",
            "in": "formData",
            "description": "Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).",
            "required": false,
            "type": "integer"
          },
          {
            "name": "TLS",
            "in": "formData",
            "description": "Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "TLSSkipVerify",
            "in": "formData",
            "description": "Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "TLSSkipClientVerify",
            "in": "formData",
            "description": "Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "TLSCACertFile",
            "in": "formData",
            "description": "TLS CA certificate file",
            "required": false,
            "type": "file"
          },
          {
            "name": "TLSCertFile",
            "in": "formData",
            "description": "TLS client certificate file",
            "required": false,
            "type": "file"
          },
          {
            "name": "TLSKeyFile",
            "in": "formData",
            "description": "TLS client key file",
            "required": false,
            "type": "file"
          },
          {
            "name": "AzureApplicationID",
            "in": "formData",
            "description": "Azure application ID. Required if environment(endpoint) type is set to 3",
            "required": false,
            "type": "string"
          },
          {
            "name": "AzureTenantID",
            "in": "formData",
            "description": "Azure tenant ID. Required if environment(endpoint) type is set to 3",
            "required": false,
            "type": "string"
          },
          {
            "name": "AzureAuthenticationKey",
            "in": "formData",
            "description": "Azure authentication key. Required if environment(endpoint) type is set to 3",
            "required": false,
            "type": "string"
          },
          {
            "name": "TagIds",
            "in": "formData",
            "description": "List of tag identifiers to which this environment(endpoint) is associated",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "EdgeCheckinInterval",
            "in": "formData",
            "description": "The check in interval for edge agent (in seconds)",
            "required": false,
            "type": "integer"
          },
          {
            "name": "EdgeTunnelServerAddress",
            "in": "formData",
            "description": "URL or IP address that will be used to establish a reverse tunnel",
            "required": true,
            "type": "string"
          },
          {
            "name": "Gpus",
            "in": "formData",
            "description": "List of GPUs - json stringified array of {name, value} structs",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Endpoint"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Name is not unique"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "endpoints"
        ],
        "summary": "Remove multiple environments",
        "description": "Deprecated: use the `POST` endpoint instead.\nRemove multiple environments and optionally clean-up associated resources.\n**Access policy**: Administrator only.",
        "operationId": "EndpointDeleteBatchDeprecated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "List of environments to delete, with optional deleteCluster flag to clean-up associated resources (cloud environments only)",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.endpointDeleteBatchPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "deprecated": true,
        "responses": {
          "204": {
            "description": "Environment(s) successfully deleted."
          },
          "207": {
            "description": "Partial success. Some environments were deleted successfully, while others failed.",
            "schema": {
              "$ref": "#/definitions/endpoints.endpointDeleteBatchPartialResponse"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to delete the specified environments."
          }
        }
      }
    },
    "/endpoints/{id}": {
      "get": {
        "tags": [
          "endpoints"
        ],
        "summary": "Inspect an environment(endpoint)",
        "description": "Retrieve details about an environment(endpoint).\n**Access policy**: restricted",
        "operationId": "EndpointInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Endpoint"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "Update an environment(endpoint)",
        "description": "Update an environment(endpoint).\n**Access policy**: authenticated",
        "operationId": "EndpointUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Environment(Endpoint) details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.endpointUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Endpoint"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "409": {
            "description": "Name is not unique"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "endpoints"
        ],
        "summary": "Remove an environment",
        "description": "Remove the environment associated to the specified identifier and optionally clean-up associated resources.\n**Access policy**: Administrator only.",
        "operationId": "EndpointDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Environment successfully deleted."
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "404": {
            "description": "Unable to find the environment with the specified identifier inside the database."
          },
          "500": {
            "description": "Server error occurred while attempting to delete the environment."
          }
        }
      }
    },
    "/endpoints/{id}/association": {
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "De-association an edge environment(endpoint)",
        "description": "De-association an edge environment(endpoint).\n**Access policy**: administrator",
        "operationId": "EndpointAssociationDelete",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/docker/v2/browse/put": {
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Upload a file under a specific path on the file system of an environment (endpoint)",
        "description": "Use this environment(endpoint) to upload TLS files.\n**Access policy**: administrator",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "volumeID",
            "in": "query",
            "description": "Optional volume identifier to upload the file",
            "required": false,
            "type": "string"
          },
          {
            "name": "Path",
            "in": "formData",
            "description": "The destination path to upload the file to",
            "required": true,
            "type": "string"
          },
          {
            "name": "file",
            "in": "formData",
            "description": "The file to upload",
            "required": true,
            "type": "file"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/dockerhub/{registryId}": {
      "get": {
        "tags": [
          "endpoints"
        ],
        "summary": "fetch docker pull limits",
        "description": "get docker pull limits for a docker hub registry in the environment\n**Access policy**:",
        "operationId": "endpointDockerhubStatus",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "endpoint ID",
            "required": true,
            "type": "integer"
          },
          {
            "name": "registryId",
            "in": "path",
            "description": "registry ID",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/endpoints.dockerhubStatusResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "registry or endpoint not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/edge/jobs/{jobID}/logs": {
      "post": {
        "tags": [
          "edge",
          "endpoints"
        ],
        "summary": "Inspect an EdgeJob Log",
        "description": "**Access policy**: public",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "environment(endpoint) Id",
            "required": true,
            "type": "integer"
          },
          {
            "name": "jobID",
            "in": "path",
            "description": "Job Id",
            "required": true,
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/endpoints/{id}/edge/stacks/{stackId}": {
      "get": {
        "tags": [
          "edge",
          "endpoints",
          "edge_stacks"
        ],
        "summary": "Inspect an Edge Stack for an Environment(Endpoint)",
        "description": "**Access policy**: public",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "environment(endpoint) Id",
            "required": true,
            "type": "integer"
          },
          {
            "name": "stackId",
            "in": "path",
            "description": "EdgeStack Id",
            "required": true,
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/edge.StackPayload"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/endpoints/{id}/edge/status": {
      "get": {
        "tags": [
          "endpoints"
        ],
        "summary": "Get environment(endpoint) status",
        "description": "environment(endpoint) for edge agent to check status of environment(endpoint)\n**Access policy**: restricted only to Edge environments(endpoints)",
        "operationId": "EndpointEdgeStatusInspect",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/endpointedge.endpointEdgeStatusInspectResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access environment(endpoint)"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/forceupdateservice": {
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "force update a docker service",
        "description": "force update a docker service\n**Access policy**: authenticated",
        "operationId": "endpointForceUpdateService",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "endpoint identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.forceUpdateServicePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/swarm.ServiceUpdateResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "endpoint not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/kubernetes/helm": {
      "get": {
        "tags": [
          "helm"
        ],
        "summary": "List Helm Releases",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmList",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "query",
            "description": "specify an optional namespace",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "specify an optional filter",
            "required": false,
            "type": "string"
          },
          {
            "name": "selector",
            "in": "query",
            "description": "specify an optional selector",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/release.ReleaseElement"
              }
            }
          },
          "400": {
            "description": "Invalid environment(endpoint) identifier"
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Environment(Endpoint) or ServiceAccount not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "helm"
        ],
        "summary": "Install Helm Chart",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmInstall",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "Chart details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/helm.installChartPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/release.Release"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Environment(Endpoint) or ServiceAccount not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/kubernetes/helm/{release}": {
      "delete": {
        "tags": [
          "helm"
        ],
        "summary": "Delete Helm Release",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "release",
            "in": "path",
            "description": "The name of the release/application to uninstall",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "query",
            "description": "An optional namespace",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid environment(endpoint) id or bad request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Environment(Endpoint) or ServiceAccount not found"
          },
          "500": {
            "description": "Server error or helm error"
          }
        }
      }
    },
    "/endpoints/{id}/registries": {
      "get": {
        "tags": [
          "endpoints"
        ],
        "summary": "List Registries on environment",
        "description": "List all registries based on the current user authorizations in current environment.\n**Access policy**: authenticated",
        "operationId": "endpointRegistriesList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "namespace",
            "in": "query",
            "description": "required if kubernetes environment, will show registries by namespace",
            "required": false,
            "type": "string"
          },
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Registry"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/registries/{registryId}": {
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "update registry access for environment",
        "description": "**Access policy**: authenticated",
        "operationId": "endpointRegistryAccess",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "registryId",
            "in": "path",
            "description": "Registry identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.registryAccessPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Endpoint not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/settings": {
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "Update settings for an environment(endpoint)",
        "description": "Update settings for an environment(endpoint).\n**Access policy**: authenticated",
        "operationId": "EndpointSettingsUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Environment(Endpoint) details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.endpointSettingsUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Endpoint"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/{id}/snapshot": {
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Snapshots an environment(endpoint)",
        "description": "Snapshots an environment(endpoint)\n**Access policy**: administrator",
        "operationId": "EndpointSnapshot",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Environment(Endpoint) not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/delete": {
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Remove multiple environments",
        "description": "Remove multiple environments and optionally clean-up associated resources.\n**Access policy**: Administrator only.",
        "operationId": "EndpointDeleteBatch",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "List of environments to delete, with optional deleteCluster flag to clean-up associated resources (cloud environments only)",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.endpointDeleteBatchPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Environment(s) successfully deleted."
          },
          "207": {
            "description": "Partial success. Some environments were deleted successfully, while others failed.",
            "schema": {
              "$ref": "#/definitions/endpoints.endpointDeleteBatchPartialResponse"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to delete the specified environments."
          }
        }
      }
    },
    "/endpoints/global-key": {
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Create or retrieve the endpoint for an EdgeID",
        "operationId": "EndpointCreateGlobalKey",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/endpoints.endpointCreateGlobalKeyResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/relations": {
      "put": {
        "tags": [
          "endpoints"
        ],
        "summary": "Update relations for a list of environments",
        "description": "Update relations for a list of environments\nEdge groups, tags and environment group can be updated.\n\n**Access policy**: administrator",
        "operationId": "EndpointUpdateRelations",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Environment relations data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/endpoints.endpointUpdateRelationsPayload"
            }
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/endpoints/snapshot": {
      "post": {
        "tags": [
          "endpoints"
        ],
        "summary": "Snapshot all environments(endpoints)",
        "description": "Snapshot all environments(endpoints)\n**Access policy**: administrator",
        "operationId": "EndpointSnapshots",
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "500": {
            "description": "Server Error"
          }
        }
      }
    },
    "/gitops/repo/file/preview": {
      "post": {
        "tags": [
          "gitops"
        ],
        "summary": "preview the content of target file in the git repository",
        "description": "Retrieve the compose file content based on git repository configuration\n**Access policy**: authenticated",
        "operationId": "GitOperationRepoFilePreview",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Template details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/gitops.repositoryFilePreviewPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/gitops.fileResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/kubernetes/{id}/applications": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of applications across all namespaces in the cluster. If the nodeName is provided, it will return the applications running on that node.",
        "description": "Get a list of applications across all namespaces in the cluster. If the nodeName is provided, it will return the applications running on that node.\n**Access policy**: authenticated",
        "operationId": "GetAllKubernetesApplications",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "query",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "name": "nodeName",
            "in": "query",
            "description": "Node name",
            "required": true,
            "type": "string"
          },
          {
            "name": "withDependencies",
            "in": "query",
            "description": "Include dependencies in the response",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sApplication"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of applications from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/applications/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get Applications count",
        "description": "Get the count of Applications across all namespaces in the cluster. If the nodeName is provided, it will return the count of applications running on that node.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesApplicationsCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the count of all applications from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/cluster_role_bindings/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete cluster role bindings",
        "description": "Delete the provided list of cluster role bindings.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteClusterRoleBindings",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A list of cluster role bindings to delete",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific cluster role binding."
          },
          "500": {
            "description": "Server error occurred while attempting to delete cluster role bindings."
          }
        }
      }
    },
    "/kubernetes/{id}/cluster_roles/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete cluster roles",
        "description": "Delete the provided list of cluster roles.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteClusterRoles",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A list of cluster roles to delete",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific cluster role."
          },
          "500": {
            "description": "Server error occurred while attempting to delete cluster roles."
          }
        }
      }
    },
    "/kubernetes/{id}/clusterrolebindings": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes cluster role bindings",
        "description": "Get a list of kubernetes cluster role bindings within the given environment at the cluster level.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesClusterRoleBindings",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sClusterRoleBinding"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of cluster role bindings."
          }
        }
      }
    },
    "/kubernetes/{id}/clusterroles": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes cluster roles",
        "description": "Get a list of kubernetes cluster roles within the given environment at the cluster level.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesClusterRoles",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sClusterRole"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of cluster roles."
          }
        }
      }
    },
    "/kubernetes/{id}/configmaps": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of ConfigMaps",
        "description": "Get a list of ConfigMaps across all namespaces in the cluster. For non-admin users, it will only return ConfigMaps based on the namespaces that they have access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesConfigMaps",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "isUsed",
            "in": "query",
            "description": "Set to true to include information about applications that use the ConfigMaps in the response",
            "required": true,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sConfigMap"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve all configmaps from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/configmaps/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get ConfigMaps count",
        "description": "Get the count of ConfigMaps across all namespaces in the cluster. For non-admin users, it will only return the count of ConfigMaps based on the namespaces that they have access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesConfigMapsCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the count of all configmaps from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/cron_jobs": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes Cron Jobs",
        "description": "Get a list of kubernetes Cron Jobs that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesCronJobs",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sCronJob"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of Cron Jobs."
          }
        }
      }
    },
    "/kubernetes/{id}/cron_jobs/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete Cron Jobs",
        "description": "Delete the provided list of Cron Jobs.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteCronJobs",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A map where the key is the namespace and the value is an array of Cron Jobs to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sCronJobDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific service account."
          },
          "500": {
            "description": "Server error occurred while attempting to delete Cron Jobs."
          }
        }
      }
    },
    "/kubernetes/{id}/dashboard": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get the dashboard summary data",
        "description": "Get the dashboard summary data which is simply a count of a range of different commonly used kubernetes resources.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesDashboard",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment (Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sDashboard"
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/kubernetes/{id}/ingresscontrollers": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of ingress controllers",
        "description": "Get a list of ingress controllers for the given environment. If the allowedOnly query parameter is set, only ingress controllers that are allowed by the environment's ingress configuration will be returned.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesIngressControllers",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "allowedOnly",
            "in": "query",
            "description": "Only return allowed ingress controllers",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressController"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve ingress controllers"
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update (block/unblock) ingress controllers",
        "description": "Update (block/unblock) ingress controllers for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesIngressControllers",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Ingress controllers",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressController"
              }
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find the ingress controllers to update."
          },
          "500": {
            "description": "Server error occurred while attempting to update ingress controllers."
          }
        }
      }
    },
    "/kubernetes/{id}/ingresses": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get kubernetes ingresses at the cluster level",
        "description": "Get kubernetes ingresses at the cluster level for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesClusterIngresses",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "withServices",
            "in": "query",
            "description": "Lookup services associated with each ingress",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve ingresses."
          }
        }
      }
    },
    "/kubernetes/{id}/ingresses/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get Ingresses count",
        "description": "Get the number of kubernetes ingresses within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesClusterIngressesCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve ingresses count."
          }
        }
      }
    },
    "/kubernetes/{id}/ingresses/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete one or more Ingresses",
        "description": "Delete one or more Ingresses in the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteKubernetesIngresses",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Ingress details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sIngressDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific ingress."
          },
          "500": {
            "description": "Server error occurred while attempting to delete specified ingresses."
          }
        }
      }
    },
    "/kubernetes/{id}/jobs": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes Jobs",
        "description": "Get a list of kubernetes Jobs that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesJobs",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "includeCronJobChildren",
            "in": "query",
            "description": "Whether to include Jobs that have a cronjob owner",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sJob"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of Jobs."
          }
        }
      }
    },
    "/kubernetes/{id}/jobs/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete Jobs",
        "description": "Delete the provided list of Jobs.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteJobs",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A map where the key is the namespace and the value is an array of Jobs to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sJobDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific service account."
          },
          "500": {
            "description": "Server error occurred while attempting to delete Jobs."
          }
        }
      }
    },
    "/kubernetes/{id}/max_resource_limits": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get max CPU and memory limits of all nodes within k8s cluster",
        "description": "Get max CPU and memory limits (unused resources) of all nodes within k8s cluster.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesMaxResourceLimits",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNodesLimits"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve nodes limits."
          }
        }
      }
    },
    "/kubernetes/{id}/metrics/applications_resources": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get the total resource requests and limits of all applications",
        "description": "Get the total CPU (cores) and memory (bytes) requests and limits of all applications across all namespaces.\n**Access policy**: Authenticated user.",
        "operationId": "GetApplicationsResources",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "node",
            "in": "query",
            "description": "Node name",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sApplicationResource"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the total resource requests and limits for all applications from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/metrics/nodes": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of nodes with their live metrics",
        "description": "Get a list of metrics associated with all nodes of a cluster.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesMetricsForAllNodes",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/v1beta1.NodeMetricsList"
            }
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of nodes with their live metrics."
          }
        }
      }
    },
    "/kubernetes/{id}/metrics/nodes/{name}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get live metrics for a node",
        "description": "Get live metrics for the specified node.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesMetricsForNode",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "name",
            "in": "path",
            "description": "Node identifier",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/v1beta1.NodeMetrics"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the live metrics for the specified node."
          }
        }
      }
    },
    "/kubernetes/{id}/metrics/pods/{namespace}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of pods with their live metrics",
        "description": "Get a list of pods with their live metrics for the specified namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesMetricsForAllPods",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/v1beta1.PodMetricsList"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of pods with their live metrics."
          }
        }
      }
    },
    "/kubernetes/{id}/metrics/pods/{namespace}/{name}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get live metrics for a pod",
        "description": "Get live metrics for the specified pod.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesMetricsForPod",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "description": "Pod identifier",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/v1beta1.PodMetrics"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the live metrics for the specified pod."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of namespaces",
        "description": "Get a list of all namespaces within the given environment based on the user role and permissions. If the user is an admin, they can access all namespaces. If the user is not an admin, they can only access namespaces that they have access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesNamespaces",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "withResourceQuota",
            "in": "query",
            "description": "When set to true, include the resource quota information as part of the Namespace information. Default is false",
            "required": true,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.K8sNamespaceInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of namespaces."
          }
        }
      },
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Create a namespace",
        "description": "Create a namespace within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "CreateKubernetesNamespace",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Namespace configuration details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sNamespaceDetails"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNamespaceInfo"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "409": {
            "description": "Conflict - the namespace already exists."
          },
          "500": {
            "description": "Server error occurred while attempting to create the namespace."
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update a namespace",
        "description": "Update a namespace within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesNamespaceDeprecated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Namespace details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sNamespaceDetails"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNamespaceInfo"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific namespace."
          },
          "500": {
            "description": "Server error occurred while attempting to update the namespace."
          }
        }
      },
      "delete": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete a kubernetes namespace",
        "description": "Delete a kubernetes namespace within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteKubernetesNamespace",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "string"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to delete the namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get namespace details",
        "description": "Get namespace details for the provided namespace within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesNamespace",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name to get details for",
            "required": true,
            "type": "string"
          },
          {
            "name": "withResourceQuota",
            "in": "query",
            "description": "When set to true, include the resource quota information as part of the Namespace information. Default is false",
            "required": true,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNamespaceInfo"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific namespace."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve specified namespace information."
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update a namespace",
        "description": "Update a namespace within the given environment.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesNamespace",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Namespace details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sNamespaceDetails"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNamespaceInfo"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific namespace."
          },
          "500": {
            "description": "Server error occurred while attempting to update the namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/configmaps/{configmap}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a ConfigMap",
        "description": "Get a ConfigMap by name for a given namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesConfigMap",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name where the configmap is located",
            "required": true,
            "type": "string"
          },
          {
            "name": "configmap",
            "in": "path",
            "description": "The configmap name to get details for",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sConfigMap"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or a configmap with the specified name in the given namespace."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve a configmap by name within the specified namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list ingress controllers by namespace",
        "description": "Get a list of ingress controllers for the given environment in the provided namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesIngressControllersByNamespace",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressController"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or a namespace with the specified name."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve ingress controllers by a namespace"
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update (block/unblock) ingress controllers by namespace",
        "description": "Update (block/unblock) ingress controllers by namespace for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesIngressControllersByNamespace",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Ingress controllers",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressController"
              }
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to update ingress controllers by namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/ingresses": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of Ingresses",
        "description": "Get a list of Ingresses. If namespace is provided, it will return the list of Ingresses in that namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesIngresses",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sIngressInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve ingresses"
          }
        }
      },
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Create an Ingress",
        "description": "Create an Ingress for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "CreateKubernetesIngress",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Ingress details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sIngressInfo"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "409": {
            "description": "Conflict - an ingress with the same name already exists in the specified namespace."
          },
          "500": {
            "description": "Server error occurred while attempting to create an ingress."
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update an Ingress",
        "description": "Update an Ingress for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesIngress",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Ingress details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sIngressInfo"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find the specified ingress."
          },
          "500": {
            "description": "Server error occurred while attempting to update the specified ingress."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/ingresses/{ingress}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get an Ingress by name",
        "description": "Get an Ingress by name for the provided environment.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesIngress",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "name": "ingress",
            "in": "path",
            "description": "Ingress name",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sIngressInfo"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find an ingress with the specified name."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve an ingress."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/secrets/{secret}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a Secret",
        "description": "Get a Secret by name for a given namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesSecret",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name where the secret is located",
            "required": true,
            "type": "string"
          },
          {
            "name": "secret",
            "in": "path",
            "description": "The secret name to get details for",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sSecret"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve a secret by name belong in a namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/services": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of services for a given namespace",
        "description": "Get a list of services for a given namespace.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesServicesByNamespace",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sServiceInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve all services for a namespace."
          }
        }
      },
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Create a service",
        "description": "Create a service within a given namespace\n**Access policy**: Authenticated user.",
        "operationId": "CreateKubernetesService",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Service definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sServiceInfo"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to create a service."
          }
        }
      },
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Update a service",
        "description": "Update a service within a given namespace.\n**Access policy**: Authenticated user.",
        "operationId": "UpdateKubernetesService",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Service definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sServiceInfo"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find the service to update."
          },
          "500": {
            "description": "Server error occurred while attempting to update a service."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/system": {
      "put": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Toggle the system state for a namespace",
        "description": "Toggle the system state for a namespace\n**Access policy**: Administrator or environment administrator.",
        "operationId": "KubernetesNamespacesToggleSystem",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Update details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.namespacesToggleSystemPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find the namespace to update."
          },
          "500": {
            "description": "Server error occurred while attempting to update the system state of the namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/{namespace}/volumes": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get Kubernetes volumes within a namespace in the given Portainer environment",
        "description": "Get a list of kubernetes volumes within the specified namespace in the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesVolumesInNamespace",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace identifier",
            "required": true,
            "type": "string"
          },
          {
            "name": "withApplications",
            "in": "query",
            "description": "When set to True, include the applications that are using the volumes. It is set to false by default",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/kubernetes.K8sVolumeInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve kubernetes volumes in the namespace."
          }
        }
      }
    },
    "/kubernetes/{id}/namespaces/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get the total number of kubernetes namespaces within the given Portainer environment.",
        "description": "Get the total number of kubernetes namespaces within the given environment, including the system namespaces. The total count depends on the user's role and permissions.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesNamespacesCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to compute the namespace count."
          }
        }
      }
    },
    "/kubernetes/{id}/nodes_limits": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get CPU and memory limits of all nodes within k8s cluster",
        "description": "Get CPU and memory limits of all nodes within k8s cluster.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesNodesLimits",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.K8sNodesLimits"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve nodes limits."
          }
        }
      }
    },
    "/kubernetes/{id}/rbac_enabled": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Check if RBAC is enabled",
        "description": "Check if RBAC is enabled in the specified Kubernetes cluster.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesRBACStatus",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "RBAC status",
            "schema": {
              "type": "boolean"
            }
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the RBAC status."
          }
        }
      }
    },
    "/kubernetes/{id}/role_bindings/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete role bindings",
        "description": "Delete the provided list of role bindings.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteRoleBindings",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A map where the key is the namespace and the value is an array of role bindings to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sRoleBindingDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific role binding."
          },
          "500": {
            "description": "Server error occurred while attempting to delete role bindings."
          }
        }
      }
    },
    "/kubernetes/{id}/rolebindings": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes role bindings",
        "description": "Get a list of kubernetes role bindings that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesRoleBindings",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sRoleBinding"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of role bindings."
          }
        }
      }
    },
    "/kubernetes/{id}/roles": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes roles",
        "description": "Get a list of kubernetes roles that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesRoles",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sRole"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of roles."
          }
        }
      }
    },
    "/kubernetes/{id}/roles/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete roles",
        "description": "Delete the provided list of roles.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteRoles",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A map where the key is the namespace and the value is an array of roles to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sRoleDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific role."
          },
          "500": {
            "description": "Server error occurred while attempting to delete roles."
          }
        }
      }
    },
    "/kubernetes/{id}/secrets": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of Secrets",
        "description": "Get a list of Secrets for a given namespace. If isUsed is set to true, information about the applications that use the secrets is also returned.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesSecrets",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "isUsed",
            "in": "query",
            "description": "When set to true, associate the Secrets with the applications that use them",
            "required": true,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sSecret"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve all secrets from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/secrets/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get Secrets count",
        "description": "Get the count of Secrets across all namespaces that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesSecretsCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the count of all secrets from the cluster."
          }
        }
      }
    },
    "/kubernetes/{id}/service_accounts/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete service accounts",
        "description": "Delete the provided list of service accounts.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteServiceAccounts",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "A map where the key is the namespace and the value is an array of service accounts to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sServiceAccountDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific service account."
          },
          "500": {
            "description": "Server error occurred while attempting to delete service accounts."
          }
        }
      }
    },
    "/kubernetes/{id}/serviceaccounts": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of kubernetes service accounts",
        "description": "Get a list of kubernetes service accounts that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesServiceAccounts",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sServiceAccount"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the list of service accounts."
          }
        }
      }
    },
    "/kubernetes/{id}/services": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a list of services",
        "description": "Get a list of services that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesServices",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "withApplications",
            "in": "query",
            "description": "Lookup applications associated with each service",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kubernetes.K8sServiceInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve all services."
          }
        }
      }
    },
    "/kubernetes/{id}/services/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get services count",
        "description": "Get the count of services that the user has access to.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesServicesCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve the total count of all services."
          }
        }
      }
    },
    "/kubernetes/{id}/services/delete": {
      "post": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Delete services",
        "description": "Delete the provided list of services.\n**Access policy**: Authenticated user.",
        "operationId": "DeleteKubernetesServices",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "A map where the key is the namespace and the value is an array of services to delete",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sServiceDeleteRequests"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier or unable to find a specific service."
          },
          "500": {
            "description": "Server error occurred while attempting to delete services."
          }
        }
      }
    },
    "/kubernetes/{id}/volumes": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get Kubernetes volumes within the given Portainer environment",
        "description": "Get a list of all kubernetes volumes within the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.\n**Access policy**: Authenticated user.",
        "operationId": "GetAllKubernetesVolumes",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "withApplications",
            "in": "query",
            "description": "When set to True, include the applications that are using the volumes. It is set to false by default",
            "required": false,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/kubernetes.K8sVolumeInfo"
              }
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve kubernetes volumes."
          }
        }
      }
    },
    "/kubernetes/{id}/volumes/{namespace}/{volume}": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get a Kubernetes volume within the given Portainer environment",
        "description": "Get a Kubernetes volume within the given environment (Endpoint). The Endpoint ID must be a valid Portainer environment identifier.\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesVolume",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace identifier",
            "required": true,
            "type": "string"
          },
          {
            "name": "volume",
            "in": "path",
            "description": "Volume name",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/kubernetes.K8sVolumeInfo"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/kubernetes/{id}/volumes/count": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Get the total number of kubernetes volumes within the given Portainer environment.",
        "description": "Get the total number of kubernetes volumes within the given environment (Endpoint). The total count depends on the user's role and permissions. The Endpoint ID must be a valid Portainer environment identifier.\n**Access policy**: Authenticated user.",
        "operationId": "getAllKubernetesVolumesCount",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "integer"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "403": {
            "description": "Unauthorized access or operation not allowed."
          },
          "500": {
            "description": "Server error occurred while attempting to retrieve kubernetes volumes count."
          }
        }
      }
    },
    "/kubernetes/config": {
      "get": {
        "tags": [
          "kubernetes"
        ],
        "summary": "Generate a kubeconfig file",
        "description": "Generate a kubeconfig file that allows a client to communicate with the Kubernetes API server\n**Access policy**: Authenticated user.",
        "operationId": "GetKubernetesConfig",
        "produces": [
          "application/json",
          " application/yaml"
        ],
        "parameters": [
          {
            "name": "ids",
            "in": "query",
            "description": "will include only these environments(endpoints)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "excludeIds",
            "in": "query",
            "description": "will exclude these environments(endpoints)",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer"
            },
            "collectionFormat": "multi"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": [],
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "object"
            }
          },
          "400": {
            "description": "Invalid request payload, such as missing required fields or fields not meeting validation criteria."
          },
          "401": {
            "description": "Unauthorized access - the user is not authenticated or does not have the necessary permissions. Ensure that you have provided a valid API key or JWT token, and that you have the required permissions."
          },
          "403": {
            "description": "Permission denied - the user is authenticated but does not have the necessary permissions to access the requested resource or perform the specified operation. Check your user roles and permissions."
          },
          "404": {
            "description": "Unable to find an environment with the specified identifier."
          },
          "500": {
            "description": "Server error occurred while attempting to generate the kubeconfig file."
          }
        }
      }
    },
    "/ldap/check": {
      "post": {
        "tags": [
          "ldap"
        ],
        "summary": "Test LDAP connectivity",
        "description": "Test LDAP connectivity using LDAP details\n**Access policy**: administrator",
        "operationId": "LDAPCheck",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ldap.checkPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/motd": {
      "get": {
        "tags": [
          "motd"
        ],
        "summary": "fetches the message of the day",
        "description": "**Access policy**: restricted",
        "operationId": "MOTD",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/motd.motdResponse"
            }
          }
        }
      }
    },
    "/open_amt": {
      "post": {
        "tags": [
          "intel"
        ],
        "summary": "Enable Portainer's OpenAMT capabilities",
        "description": "Enable Portainer's OpenAMT capabilities\n**Access policy**: administrator",
        "operationId": "OpenAMTConfigure",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "OpenAMT Settings",
            "required": true,
            "schema": {
              "$ref": "#/definitions/openamt.openAMTConfigurePayload"
            }
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/open_amt/{id}/activate": {
      "post": {
        "tags": [
          "intel"
        ],
        "summary": "Activate OpenAMT device and associate to agent endpoint",
        "description": "Activate OpenAMT device and associate to agent endpoint\n**Access policy**: administrator",
        "operationId": "openAMTActivate",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/open_amt/{id}/devices": {
      "get": {
        "tags": [
          "intel"
        ],
        "summary": "Fetch OpenAMT managed devices information for endpoint",
        "description": "Fetch OpenAMT managed devices information for endpoint\n**Access policy**: administrator",
        "operationId": "OpenAMTDevices",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment(Endpoint) identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/open_amt/{id}/devices/{deviceId}/action": {
      "post": {
        "tags": [
          "intel"
        ],
        "summary": "Execute out of band action on an AMT managed device",
        "description": "Execute out of band action on an AMT managed device\n**Access policy**: administrator",
        "operationId": "DeviceAction",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "deviceId",
            "in": "path",
            "description": "Device identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Device Action",
            "required": true,
            "schema": {
              "$ref": "#/definitions/openamt.deviceActionPayload"
            }
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/open_amt/{id}/devices_features/{deviceId}": {
      "post": {
        "tags": [
          "intel"
        ],
        "summary": "Enable features on an AMT managed device",
        "description": "Enable features on an AMT managed device\n**Access policy**: administrator",
        "operationId": "DeviceFeatures",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "deviceId",
            "in": "path",
            "description": "Device identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Device Features",
            "required": true,
            "schema": {
              "$ref": "#/definitions/openamt.deviceFeaturesPayload"
            }
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/open_amt/{id}/info": {
      "get": {
        "tags": [
          "intel"
        ],
        "summary": "Request OpenAMT info from a node",
        "description": "Request OpenAMT info from a node\n**Access policy**: administrator",
        "operationId": "OpenAMTHostInfo",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/registries": {
      "get": {
        "tags": [
          "registries"
        ],
        "summary": "List Registries",
        "description": "List all registries based on the current user authorizations.\nWill return all registries if using an administrator account otherwise it\nwill only return authorized registries.\n**Access policy**: restricted",
        "operationId": "RegistryList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Registry"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "registries"
        ],
        "summary": "Create a new registry",
        "description": "Create a new registry.\n**Access policy**: restricted",
        "operationId": "RegistryCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Registry details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/registries.registryCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Registry"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Another registry with the same name or same URL & credentials already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/registries/{id}": {
      "get": {
        "tags": [
          "registries"
        ],
        "summary": "Inspect a registry",
        "description": "Retrieve details about a registry.\n**Access policy**: restricted",
        "operationId": "RegistryInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Registry identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Registry"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access registry"
          },
          "404": {
            "description": "Registry not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "registries"
        ],
        "summary": "Update a registry",
        "description": "Update a registry\n**Access policy**: restricted",
        "operationId": "RegistryUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Registry identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Registry details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/registries.registryUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Registry"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Registry not found"
          },
          "409": {
            "description": "Another registry with the same name or same URL & credentials already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "registries"
        ],
        "summary": "Remove a registry",
        "description": "Remove a registry\n**Access policy**: restricted",
        "operationId": "RegistryDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Registry identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Registry not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/registries/{id}/configure": {
      "post": {
        "tags": [
          "registries"
        ],
        "summary": "Configures a registry",
        "description": "Configures a registry.\n**Access policy**: restricted",
        "operationId": "RegistryConfigure",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Registry identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Registry configuration",
            "required": true,
            "schema": {
              "$ref": "#/definitions/registries.registryConfigurePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Registry not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/resource_controls": {
      "post": {
        "tags": [
          "resource_controls"
        ],
        "summary": "Create a new resource control",
        "description": "Create a new resource control to restrict access to a Docker resource.\n**Access policy**: administrator",
        "operationId": "ResourceControlCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Resource control details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/resourcecontrols.resourceControlCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.ResourceControl"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "A resource control is already associated to this resource"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/resource_controls/{id}": {
      "put": {
        "tags": [
          "resource_controls"
        ],
        "summary": "Update a resource control",
        "description": "Update a resource control\n**Access policy**: authenticated",
        "operationId": "ResourceControlUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Resource control identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Resource control details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/resourcecontrols.resourceControlUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.ResourceControl"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Resource control not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "resource_controls"
        ],
        "summary": "Remove a resource control",
        "description": "Remove a resource control.\n**Access policy**: administrator",
        "operationId": "ResourceControlDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Resource control identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "404": {
            "description": "Resource control not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/restore": {
      "post": {
        "tags": [
          "backup"
        ],
        "summary": "Triggers a system restore using provided backup file",
        "description": "Triggers a system restore using provided backup file\n**Access policy**: public",
        "operationId": "Restore",
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "restorePayload",
            "description": "Restore request payload",
            "required": true,
            "schema": {
              "$ref": "#/definitions/backup.restorePayload"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/roles": {
      "get": {
        "tags": [
          "roles"
        ],
        "summary": "List roles",
        "description": "List all roles available for use\n**Access policy**: administrator",
        "operationId": "RoleList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Role"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/settings": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Retrieve Portainer settings",
        "description": "Retrieve Portainer settings.\n**Access policy**: administrator",
        "operationId": "SettingsInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Settings"
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "settings"
        ],
        "summary": "Update Portainer settings",
        "description": "Update Portainer settings.\n**Access policy**: administrator",
        "operationId": "SettingsUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "New settings",
            "required": true,
            "schema": {
              "$ref": "#/definitions/settings.settingsUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Settings"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/settings/public": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Retrieve Portainer public settings",
        "description": "Retrieve public settings. Returns a small set of settings that are not reserved to administrators only.\n**Access policy**: public",
        "operationId": "SettingsPublic",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/settings.publicSettingsResponse"
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/ssl": {
      "get": {
        "tags": [
          "ssl"
        ],
        "summary": "Inspect the ssl settings",
        "description": "Retrieve the ssl settings.\n**Access policy**: administrator",
        "operationId": "SSLInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.SSLSettings"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "ssl"
        ],
        "summary": "Update the ssl settings",
        "description": "Update the ssl settings.\n**Access policy**: administrator",
        "operationId": "SSLUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "SSL Settings",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ssl.sslUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to access settings"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks": {
      "get": {
        "tags": [
          "stacks"
        ],
        "summary": "List stacks",
        "description": "List all stacks based on the current user authorizations.\nWill return all stacks if using an administrator account otherwise it\nwill only return the list of stacks the user have access to.\nLimited stacks will not be returned by this endpoint.\n**Access policy**: authenticated",
        "operationId": "StackList",
        "parameters": [
          {
            "name": "filters",
            "in": "query",
            "description": "Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {'SwarmID': 'jpofkc0i9uo9wtx1zesuk649w'} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Stack"
              }
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}": {
      "get": {
        "tags": [
          "stacks"
        ],
        "summary": "Inspect a stack",
        "description": "Retrieve details about a stack.\n**Access policy**: restricted",
        "operationId": "StackInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Stack not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "stacks"
        ],
        "summary": "Update a stack",
        "description": "Update a stack, only for file based stacks.\n**Access policy**: authenticated",
        "operationId": "StackUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Stack details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.updateSwarmStackPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "stacks"
        ],
        "summary": "Remove a stack",
        "description": "Remove a stack.\n**Access policy**: restricted",
        "operationId": "StackDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "external",
            "in": "query",
            "description": "Set to true to delete an external stack. Only external Swarm stacks are supported",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/associate": {
      "put": {
        "tags": [
          "stacks"
        ],
        "summary": "Associate an orphaned stack to a new environment(endpoint)",
        "description": "**Access policy**: administrator",
        "operationId": "StackAssociate",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "swarmId",
            "in": "query",
            "description": "Swarm identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "orphanedRunning",
            "in": "query",
            "description": "Indicates whether the stack is orphaned",
            "required": true,
            "type": "boolean"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Stack not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/file": {
      "get": {
        "tags": [
          "stacks"
        ],
        "summary": "Retrieve the content of the Stack file for the specified stack",
        "description": "Get Stack file content.\n**Access policy**: restricted",
        "operationId": "StackFileInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/stacks.stackFileResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Stack not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/git": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Update a stack's Git configs",
        "description": "Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate\n**Access policy**: authenticated",
        "operationId": "StackUpdateGit",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Git configs for pull and redeploy a stack",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.stackGitUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/git/redeploy": {
      "put": {
        "tags": [
          "stacks"
        ],
        "summary": "Redeploy a stack",
        "description": "Pull and redeploy a stack via Git\n**Access policy**: authenticated",
        "operationId": "StackGitRedeploy",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.stackGitRedployPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/migrate": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Migrate a stack to another environment(endpoint)",
        "description": "Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack.\n**Access policy**: authenticated",
        "operationId": "StackMigrate",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Stack migration details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.stackMigratePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Stack not found"
          },
          "409": {
            "description": "A stack with the same name is already running on the target environment(endpoint)"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/start": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Starts a stopped Stack",
        "description": "Starts a stopped Stack.\n**Access policy**: authenticated",
        "operationId": "StackStart",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "409": {
            "description": "Stack name is not unique"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/{id}/stop": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Stops a stopped Stack",
        "description": "Stops a stopped Stack.\n**Access policy**: authenticated",
        "operationId": "StackStop",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/kubernetes/repository": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new kubernetes stack from a git repository",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateKubernetesGit",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.kubernetesGitDeploymentPayload"
            }
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Stack name or webhook ID already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/kubernetes/string": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new kubernetes stack from a file",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateKubernetesFile",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.kubernetesStringDeploymentPayload"
            }
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/kubernetes/url": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new kubernetes stack from a url",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateKubernetesUrl",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.kubernetesManifestURLDeploymentPayload"
            }
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/standalone/file": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new compose stack from a file",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerStandaloneFile",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "Name",
            "in": "formData",
            "description": "Name of the stack",
            "required": true,
            "type": "string"
          },
          {
            "name": "Env",
            "in": "formData",
            "description": "Environment variables passed during deployment, represented as a JSON array [{'name': 'name', 'value': 'value'}].",
            "required": false,
            "type": "string"
          },
          {
            "name": "file",
            "in": "formData",
            "description": "Stack file",
            "required": false,
            "type": "file"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/standalone/repository": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new compose stack from repository",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerStandaloneRepository",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.composeStackFromGitRepositoryPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Stack name or webhook ID already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/standalone/string": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new compose stack from a text",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerStandaloneString",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.composeStackFromFileContentPayload"
            }
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/swarm/file": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new swarm stack from a file",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerSwarmFile",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "Name",
            "in": "formData",
            "description": "Name of the stack",
            "required": false,
            "type": "string"
          },
          {
            "name": "SwarmID",
            "in": "formData",
            "description": "Swarm cluster identifier.",
            "required": false,
            "type": "string"
          },
          {
            "name": "Env",
            "in": "formData",
            "description": "Environment variables passed during deployment, represented as a JSON array [{'name': 'name', 'value': 'value'}]. Optional",
            "required": false,
            "type": "string"
          },
          {
            "name": "file",
            "in": "formData",
            "description": "Stack file",
            "required": false,
            "type": "file"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/swarm/repository": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new swarm stack from a git repository",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerSwarmRepository",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.swarmStackFromGitRepositoryPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Stack name or webhook ID already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/create/swarm/string": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Deploy a new swarm stack from a text",
        "description": "Deploy a new stack into a Docker environment specified via the environment identifier.\n**Access policy**: authenticated",
        "operationId": "StackCreateDockerSwarmString",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "stack config",
            "required": true,
            "schema": {
              "$ref": "#/definitions/stacks.swarmStackFromFileContentPayload"
            }
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Identifier of the environment that will be used to deploy the stack",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Stack"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/name/{name}": {
      "delete": {
        "tags": [
          "stacks"
        ],
        "summary": "Remove Kubernetes stacks by name",
        "description": "Remove a stack.\n**Access policy**: restricted",
        "operationId": "StackDeleteKubernetesByName",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "Stack name",
            "required": true,
            "type": "string"
          },
          {
            "name": "external",
            "in": "query",
            "description": "Set to true to delete an external stack. Only external Swarm stacks are supported",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "endpointId",
            "in": "query",
            "description": "Environment identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/stacks/webhooks/{webhookID}": {
      "post": {
        "tags": [
          "stacks"
        ],
        "summary": "Webhook for triggering stack updates from git",
        "description": "**Access policy**: public",
        "operationId": "WebhookInvoke",
        "parameters": [
          {
            "name": "webhookID",
            "in": "path",
            "description": "Stack identifier",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Autoupdate for the stack isn't available"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/status": {
      "get": {
        "tags": [
          "status"
        ],
        "summary": "Check Portainer status",
        "description": "Deprecated: use the `/system/status` endpoint instead.\nRetrieve Portainer status\n**Access policy**: public",
        "operationId": "StatusInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "deprecated": true,
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.status"
            }
          }
        }
      }
    },
    "/system/info": {
      "get": {
        "tags": [
          "system"
        ],
        "summary": "Retrieve system info",
        "description": "**Access policy**: authenticated",
        "operationId": "systemInfo",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.systemInfoResponse"
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/system/nodes": {
      "get": {
        "tags": [
          "system"
        ],
        "summary": "Retrieve the count of nodes",
        "description": "**Access policy**: authenticated",
        "operationId": "systemNodesCount",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.nodesCountResponse"
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/system/status": {
      "get": {
        "tags": [
          "system"
        ],
        "summary": "Check Portainer status",
        "description": "Retrieve Portainer status\n**Access policy**: public",
        "operationId": "systemStatus",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.status"
            }
          }
        }
      }
    },
    "/system/upgrade": {
      "post": {
        "tags": [
          "system"
        ],
        "summary": "Upgrade Portainer to BE",
        "description": "Upgrade Portainer to BE\n**Access policy**: administrator",
        "operationId": "systemUpgrade",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "204": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.status"
            }
          }
        }
      }
    },
    "/system/version": {
      "get": {
        "tags": [
          "system"
        ],
        "summary": "Check for portainer updates",
        "description": "Check if portainer has an update available\n**Access policy**: authenticated",
        "operationId": "systemVersion",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/system.versionResponse"
            }
          }
        }
      }
    },
    "/tags": {
      "get": {
        "tags": [
          "tags"
        ],
        "summary": "List tags",
        "description": "List tags.\n**Access policy**: authenticated",
        "operationId": "TagList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Tag"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "tags"
        ],
        "summary": "Create a new tag",
        "description": "Create a new tag.\n**Access policy**: administrator",
        "operationId": "TagCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Tag details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/tags.tagCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Tag"
            }
          },
          "409": {
            "description": "This name is already associated to a tag"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/tags/{id}": {
      "delete": {
        "tags": [
          "tags"
        ],
        "summary": "Remove a tag",
        "description": "Remove a tag.\n**Access policy**: administrator",
        "operationId": "TagDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Tag identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Tag not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/team_memberships": {
      "get": {
        "tags": [
          "team_memberships"
        ],
        "summary": "List team memberships",
        "description": "List team memberships. Access is only available to administrators and team leaders.\n**Access policy**: administrator",
        "operationId": "TeamMembershipList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.TeamMembership"
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "team_memberships"
        ],
        "summary": "Create a new team membership",
        "description": "Create a new team memberships. Access is only available to administrators leaders of the associated team.\n**Access policy**: administrator",
        "operationId": "TeamMembershipCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Team membership details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/teammemberships.teamMembershipCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.TeamMembership"
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied to manage memberships"
          },
          "409": {
            "description": "Team membership already registered"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/team_memberships/{id}": {
      "put": {
        "tags": [
          "team_memberships"
        ],
        "summary": "Update a team membership",
        "description": "Update a team membership. Access is only available to administrators or leaders of the associated team.\n**Access policy**: administrator or leaders of the associated team",
        "operationId": "TeamMembershipUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Team membership identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Team membership details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/teammemberships.teamMembershipUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.TeamMembership"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "TeamMembership not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "team_memberships"
        ],
        "summary": "Remove a team membership",
        "description": "Remove a team membership. Access is only available to administrators leaders of the associated team.\n**Access policy**: administrator",
        "operationId": "TeamMembershipDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "TeamMembership identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "TeamMembership not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/teams": {
      "get": {
        "tags": [
          "teams"
        ],
        "summary": "List teams",
        "description": "List teams. For non-administrator users, will only list the teams they are member of.\n**Access policy**: restricted",
        "operationId": "TeamList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "onlyLedTeams",
            "in": "query",
            "description": "Only list teams that the user is leader of",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "environmentId",
            "in": "query",
            "description": "Identifier of the environment(endpoint) that will be used to filter the authorized teams",
            "required": false,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Team"
              }
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "teams"
        ],
        "summary": "Create a new team",
        "description": "Create a new team.\n**Access policy**: administrator",
        "operationId": "TeamCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/teams.teamCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Team"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "A team with the same name already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/teams/{id}": {
      "get": {
        "tags": [
          "teams"
        ],
        "summary": "Inspect a team",
        "description": "Retrieve details about a team. Access is only available for administrator and leaders of that team.\n**Access policy**: administrator",
        "operationId": "TeamInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Team identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Team"
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Team not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "teams"
        ],
        "summary": "Update a team",
        "description": "Update a team.\n**Access policy**: administrator",
        "operationId": "TeamUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Team identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Team details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/teams.teamUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.Team"
            }
          },
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Team not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "teams"
        ],
        "summary": "Remove a team",
        "description": "Remove a team.\n**Access policy**: administrator",
        "operationId": "TeamDelete",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Team Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Team not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/teams/{id}/memberships": {
      "get": {
        "tags": [
          "team_memberships"
        ],
        "summary": "List team memberships",
        "description": "List team memberships. Access is only available to administrators and team leaders.\n**Access policy**: restricted",
        "operationId": "TeamMemberships",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Team Id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.TeamMembership"
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/templates": {
      "get": {
        "tags": [
          "templates"
        ],
        "summary": "List available templates",
        "description": "List available templates.\n**Access policy**: authenticated",
        "operationId": "TemplateList",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/templates.listResponse"
            }
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/templates/{id}/file": {
      "post": {
        "tags": [
          "templates"
        ],
        "summary": "Get a template's file",
        "description": "Get a template's file\n**Access policy**: authenticated",
        "operationId": "TemplateFile",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Template identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/templates.fileResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/templates/helm": {
      "get": {
        "tags": [
          "helm"
        ],
        "summary": "Search Helm Charts",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmRepoSearch",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "repo",
            "in": "query",
            "description": "Helm repository URL",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/templates/helm/{command}": {
      "get": {
        "tags": [
          "helm"
        ],
        "summary": "Show Helm Chart Information",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmShow",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "text/plain"
        ],
        "parameters": [
          {
            "name": "repo",
            "in": "query",
            "description": "Helm repository URL",
            "required": true,
            "type": "string"
          },
          {
            "name": "chart",
            "in": "query",
            "description": "Chart name",
            "required": true,
            "type": "string"
          },
          {
            "name": "command",
            "in": "path",
            "description": "chart/values/readme",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "string"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Environment(Endpoint) or ServiceAccount not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/upload/tls/{certificate}": {
      "post": {
        "tags": [
          "upload"
        ],
        "summary": "Upload TLS files",
        "description": "Use this environment(endpoint) to upload TLS files.\n**Access policy**: administrator",
        "operationId": "UploadTLS",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "certificate",
            "in": "path",
            "description": "TLS file type. Valid values are 'ca', 'cert' or 'key'.",
            "required": true,
            "type": "string",
            "enum": [
              "ca",
              "cert",
              "key"
            ]
          },
          {
            "name": "folder",
            "in": "formData",
            "description": "Folder where the TLS file will be stored. Will be created if not existing",
            "required": true,
            "type": "string"
          },
          {
            "name": "file",
            "in": "formData",
            "description": "The file to upload",
            "required": true,
            "type": "file"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "List users",
        "description": "List Portainer users.\nNon-administrator users will only be able to list other non-administrator user accounts.\nUser passwords are filtered out, and should never be accessible.\n**Access policy**: restricted",
        "operationId": "UserList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "environmentId",
            "in": "query",
            "description": "Identifier of the environment(endpoint) that will be used to filter the authorized users",
            "required": false,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.User"
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "users"
        ],
        "summary": "Create a new user",
        "description": "Create a new Portainer user.\nOnly administrators can create users.\n**Access policy**: restricted",
        "operationId": "UserCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "User details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.userCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.User"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "409": {
            "description": "User already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Inspect a user",
        "description": "Retrieve details about a user.\nUser passwords are filtered out, and should never be accessible.\n**Access policy**: authenticated",
        "operationId": "UserInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.User"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "put": {
        "tags": [
          "users"
        ],
        "summary": "Update a user",
        "description": "Update user details. A regular user account can only update his details.\nA regular user account cannot change their username or role.\n**Access policy**: authenticated",
        "operationId": "UserUpdate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "User details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.userUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.User"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "409": {
            "description": "Username already exist"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Remove a user",
        "description": "Remove a user.\n**Access policy**: administrator",
        "operationId": "UserDelete",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/helm/repositories": {
      "get": {
        "tags": [
          "helm"
        ],
        "summary": "List a users helm repositories",
        "description": "Inspect a user helm repositories.\n**Access policy**: authenticated",
        "operationId": "HelmUserRepositoriesList",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/users.helmUserRepositoryResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "helm"
        ],
        "summary": "Create a user helm repository",
        "description": "Create a user helm repository.\n**Access policy**: authenticated",
        "operationId": "HelmUserRepositoryCreate",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "payload",
            "description": "Helm Repository",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.addHelmRepoUrlPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.HelmUserRepository"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/helm/repositories/{repositoryID}": {
      "delete": {
        "tags": [
          "helm"
        ],
        "summary": "Delete a users helm repositoryies",
        "description": "**Access policy**: authenticated",
        "operationId": "HelmUserRepositoryDelete",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "repositoryID",
            "in": "path",
            "description": "Repository identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/memberships": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Inspect a user memberships",
        "description": "Inspect a user memberships.\n**Access policy**: restricted",
        "operationId": "UserMembershipsInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.TeamMembership"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/passwd": {
      "put": {
        "tags": [
          "users"
        ],
        "summary": "Update password for a user",
        "description": "Update password for the specified user.\n**Access policy**: authenticated",
        "operationId": "UserUpdatePassword",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.userUpdatePasswordPayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/tokens": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Get all API keys for a user",
        "description": "Gets all API keys for a user.\nOnly the calling user or admin can retrieve api-keys.\n**Access policy**: authenticated",
        "operationId": "UserGetAPIKeys",
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.APIKey"
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      },
      "post": {
        "tags": [
          "users"
        ],
        "summary": "Generate an API key for a user",
        "description": "Generates an API key for a user.\nOnly the calling user can generate a token for themselves.\nPassword is required only for internal authentication.\n**Access policy**: restricted",
        "operationId": "UserGenerateAPIKey",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.userAccessTokenCreatePayload"
            }
          }
        ],
        "security": [
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/users.accessTokenResponse"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/{id}/tokens/{keyID}": {
      "delete": {
        "tags": [
          "users"
        ],
        "summary": "Remove an api-key associated to a user",
        "description": "Remove an api-key associated to a user..\nOnly the calling user or admin can remove api-key.\n**Access policy**: authenticated",
        "operationId": "UserRemoveAPIKey",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "User identifier",
            "required": true,
            "type": "integer"
          },
          {
            "name": "keyID",
            "in": "path",
            "description": "Api Key identifier",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "Not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/admin/check": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Check administrator account existence",
        "description": "Check if an administrator account exists in the database.\n**Access policy**: public",
        "operationId": "UserAdminCheck",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "description": "User not found"
          }
        }
      }
    },
    "/users/admin/init": {
      "post": {
        "tags": [
          "users"
        ],
        "summary": "Initialize administrator account",
        "description": "Initialize the 'admin' user account.\n**Access policy**: public",
        "operationId": "UserAdminInit",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "User details",
            "required": true,
            "schema": {
              "$ref": "#/definitions/users.adminInitPayload"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.User"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "Admin user already initialized"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Inspect the current user user",
        "description": "Retrieve details about the current  user.\nUser passwords are filtered out, and should never be accessible.\n**Access policy**: authenticated",
        "operationId": "CurrentUserInspect",
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/portainer.User"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "404": {
            "description": "User not found"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/webhooks": {
      "get": {
        "tags": [
          "webhooks"
        ],
        "summary": "List webhooks",
        "description": "**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "filters",
            "in": "query",
            "description": "Filters (json-string)",
            "required": false,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/portainer.Webhook"
              }
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "post": {
        "tags": [
          "webhooks"
        ],
        "summary": "Create a webhook",
        "description": "**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Webhook data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/webhooks.webhookCreatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Webhook"
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "409": {
            "description": "A webhook for this resource already exists"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/webhooks/{id}": {
      "post": {
        "tags": [
          "webhooks"
        ],
        "summary": "Execute a webhook",
        "description": "Acts on a passed in token UUID to restart the docker service\n**Access policy**: public",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Webhook token",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Webhook executed"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "put": {
        "tags": [
          "webhooks"
        ],
        "summary": "Update a webhook",
        "description": "**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Webhook id",
            "required": true,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "Webhook data",
            "required": true,
            "schema": {
              "$ref": "#/definitions/webhooks.webhookUpdatePayload"
            }
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/portainer.Webhook"
            }
          },
          "400": {
            "description": "Bad Request"
          },
          "409": {
            "description": "Conflict"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      },
      "delete": {
        "tags": [
          "webhooks"
        ],
        "summary": "Delete a webhook",
        "description": "**Access policy**: authenticated",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Webhook id",
            "required": true,
            "type": "integer"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "202": {
            "description": "Webhook deleted"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/websocket/attach": {
      "get": {
        "tags": [
          "websocket"
        ],
        "summary": "Attach a websocket",
        "description": "If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint).\nIf the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and\nan AttachStart operation HTTP request will be created and hijacked.\n**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "environment(endpoint) ID of the environment(endpoint) where the resource is located",
            "required": true,
            "type": "integer"
          },
          {
            "name": "nodeName",
            "in": "query",
            "description": "node name",
            "required": false,
            "type": "string"
          },
          {
            "name": "token",
            "in": "query",
            "description": "JWT token used for authentication against this environment(endpoint)",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/websocket/exec": {
      "get": {
        "tags": [
          "websocket"
        ],
        "summary": "Execute a websocket",
        "description": "If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint).\nIf the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and\nan ExecStart operation HTTP request will be created and hijacked.",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "environment(endpoint) ID of the environment(endpoint) where the resource is located",
            "required": true,
            "type": "integer"
          },
          {
            "name": "nodeName",
            "in": "query",
            "description": "node name",
            "required": false,
            "type": "string"
          },
          {
            "name": "token",
            "in": "query",
            "description": "JWT token used for authentication against this environment(endpoint)",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "409": {
            "description": "Conflict"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/websocket/kubernetes-shell": {
      "get": {
        "tags": [
          "websocket"
        ],
        "summary": "Execute a websocket on kubectl shell pod",
        "description": "The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection.\n**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "environment(endpoint) ID of the environment(endpoint) where the resource is located",
            "required": true,
            "type": "integer"
          },
          {
            "name": "token",
            "in": "query",
            "description": "JWT token used for authentication against this environment(endpoint)",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "description": "Invalid request"
          },
          "403": {
            "description": "Permission denied"
          },
          "500": {
            "description": "Server error"
          }
        }
      }
    },
    "/websocket/pod": {
      "get": {
        "tags": [
          "websocket"
        ],
        "summary": "Execute a websocket on pod",
        "description": "The request will be upgraded to the websocket protocol.\n**Access policy**: authenticated",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "environment(endpoint) ID of the environment(endpoint) where the resource is located",
            "required": true,
            "type": "integer"
          },
          {
            "name": "namespace",
            "in": "query",
            "description": "namespace where the container is located",
            "required": true,
            "type": "string"
          },
          {
            "name": "podName",
            "in": "query",
            "description": "name of the pod containing the container",
            "required": true,
            "type": "string"
          },
          {
            "name": "containerName",
            "in": "query",
            "description": "name of the container",
            "required": true,
            "type": "string"
          },
          {
            "name": "command",
            "in": "query",
            "description": "command to execute in the container",
            "required": true,
            "type": "string"
          },
          {
            "name": "token",
            "in": "query",
            "description": "JWT token used for authentication against this environment(endpoint)",
            "required": true,
            "type": "string"
          }
        ],
        "security": [
          {
            "ApiKeyAuth": []
          },
          {
            "jwt": []
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    }
  },
  "securityDefinitions": {
    "ApiKeyAuth": {
      "type": "apiKey",
      "name": "X-API-KEY",
      "in": "header"
    },
    "jwt": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "definitions": {
    "auth.authenticatePayload": {
      "type": "object",
      "required": [
        "password",
        "username"
      ],
      "properties": {
        "password": {
          "type": "string",
          "example": "mypassword",
          "description": "Password"
        },
        "username": {
          "type": "string",
          "example": "admin",
          "description": "Username"
        }
      }
    },
    "auth.authenticateResponse": {
      "type": "object",
      "properties": {
        "jwt": {
          "type": "string",
          "example": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyzAB",
          "description": "JWT token used to authenticate against the API"
        }
      }
    },
    "auth.oauthPayload": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "OAuth code returned from OAuth Provided"
        }
      }
    },
    "backup.backupPayload": {
      "type": "object",
      "properties": {
        "password": {
          "type": "string"
        }
      }
    },
    "backup.restorePayload": {
      "type": "object",
      "properties": {
        "fileContent": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "fileName": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "build.BuildInfo": {
      "type": "object",
      "properties": {
        "buildNumber": {
          "type": "string"
        },
        "gitCommit": {
          "type": "string"
        },
        "goVersion": {
          "type": "string"
        },
        "imageTag": {
          "type": "string"
        },
        "nodejsVersion": {
          "type": "string"
        },
        "webpackVersion": {
          "type": "string"
        },
        "yarnVersion": {
          "type": "string"
        }
      }
    },
    "build.DependenciesInfo": {
      "type": "object",
      "properties": {
        "composeVersion": {
          "type": "string"
        },
        "dockerVersion": {
          "type": "string"
        },
        "helmVersion": {
          "type": "string"
        },
        "kubectlVersion": {
          "type": "string"
        }
      }
    },
    "build.RuntimeInfo": {
      "type": "object",
      "properties": {
        "env": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "containers.containerGpusResponse": {
      "type": "object",
      "properties": {
        "gpus": {
          "type": "string"
        }
      }
    },
    "customtemplates.customTemplateFromFileContentPayload": {
      "type": "object",
      "required": [
        "description",
        "fileContent",
        "title",
        "type"
      ],
      "properties": {
        "description": {
          "type": "string",
          "example": "High performance web server",
          "description": "Description of the template"
        },
        "edgeTemplate": {
          "type": "boolean",
          "example": false,
          "description": "EdgeTemplate indicates if this template purpose for Edge Stack"
        },
        "fileContent": {
          "type": "string",
          "description": "Content of stack file"
        },
        "logo": {
          "type": "string",
          "example": "https://portainer.io/img/logo.svg",
          "description": "URL of the template's logo"
        },
        "note": {
          "type": "string",
          "example": "This is my <b>custom</b> template",
          "description": "A note that will be displayed in the UI. Supports HTML content"
        },
        "platform": {
          "type": "integer",
          "example": 1,
          "description": "Platform associated to the template.\nValid values are: 1 - 'linux', 2 - 'windows'\nRequired for Docker stacks"
        },
        "title": {
          "type": "string",
          "example": "Nginx",
          "description": "Title of the template"
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Type of created stack:\n* 1 - swarm\n* 2 - compose\n* 3 - kubernetes"
        },
        "variables": {
          "type": "array",
          "description": "Definitions of variables in the stack file",
          "items": {
            "$ref": "#/definitions/portainer.CustomTemplateVariableDefinition"
          }
        }
      }
    },
    "customtemplates.customTemplateFromGitRepositoryPayload": {
      "type": "object",
      "required": [
        "description",
        "repositoryURL",
        "title",
        "type"
      ],
      "properties": {
        "composeFilePathInRepository": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file inside the Git repository",
          "default": "docker-compose.yml"
        },
        "description": {
          "type": "string",
          "example": "High performance web server",
          "description": "Description of the template"
        },
        "edgeTemplate": {
          "type": "boolean",
          "example": false,
          "description": "EdgeTemplate indicates if this template purpose for Edge Stack"
        },
        "isComposeFormat": {
          "type": "boolean",
          "example": false,
          "description": "IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file"
        },
        "logo": {
          "type": "string",
          "example": "https://portainer.io/img/logo.svg",
          "description": "URL of the template's logo"
        },
        "note": {
          "type": "string",
          "example": "This is my <b>custom</b> template",
          "description": "A note that will be displayed in the UI. Supports HTML content"
        },
        "platform": {
          "type": "integer",
          "example": 1,
          "description": "Platform associated to the template.\nValid values are: 1 - 'linux', 2 - 'windows'\nRequired for Docker stacks"
        },
        "repositoryAuthentication": {
          "type": "boolean",
          "example": true,
          "description": "Use basic authentication to clone the Git repository"
        },
        "repositoryPassword": {
          "type": "string",
          "example": "myGitPassword",
          "description": "Password used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "repositoryReferenceName": {
          "type": "string",
          "example": "refs/heads/master",
          "description": "Reference name of a Git repository hosting the Stack file"
        },
        "repositoryURL": {
          "type": "string",
          "example": "https://github.com/openfaas/faas",
          "description": "URL of a Git repository hosting the Stack file"
        },
        "repositoryUsername": {
          "type": "string",
          "example": "myGitUsername",
          "description": "Username used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "title": {
          "type": "string",
          "example": "Nginx",
          "description": "Title of the template"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Type of created stack:\n* 1 - swarm\n* 2 - compose\n* 3 - kubernetes"
        },
        "variables": {
          "type": "array",
          "description": "Definitions of variables in the stack file",
          "items": {
            "$ref": "#/definitions/portainer.CustomTemplateVariableDefinition"
          }
        }
      }
    },
    "customtemplates.customTemplateUpdatePayload": {
      "type": "object",
      "required": [
        "description",
        "fileContent",
        "repositoryURL",
        "title",
        "type"
      ],
      "properties": {
        "composeFilePathInRepository": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file inside the Git repository",
          "default": "docker-compose.yml"
        },
        "description": {
          "type": "string",
          "example": "High performance web server",
          "description": "Description of the template"
        },
        "edgeTemplate": {
          "type": "boolean",
          "example": false,
          "description": "EdgeTemplate indicates if this template purpose for Edge Stack"
        },
        "fileContent": {
          "type": "string",
          "description": "Content of stack file"
        },
        "isComposeFormat": {
          "type": "boolean",
          "example": false,
          "description": "IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file"
        },
        "logo": {
          "type": "string",
          "example": "https://portainer.io/img/logo.svg",
          "description": "URL of the template's logo"
        },
        "note": {
          "type": "string",
          "example": "This is my <b>custom</b> template",
          "description": "A note that will be displayed in the UI. Supports HTML content"
        },
        "platform": {
          "type": "integer",
          "example": 1,
          "description": "Platform associated to the template.\nValid values are: 1 - 'linux', 2 - 'windows'\nRequired for Docker stacks"
        },
        "repositoryAuthentication": {
          "type": "boolean",
          "example": true,
          "description": "Use basic authentication to clone the Git repository"
        },
        "repositoryGitCredentialID": {
          "type": "integer",
          "example": 0,
          "description": "GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication\nis true and RepositoryUsername/RepositoryPassword are not provided"
        },
        "repositoryPassword": {
          "type": "string",
          "example": "myGitPassword",
          "description": "Password used in basic authentication. Required when RepositoryAuthentication is true\nand RepositoryGitCredentialID is 0"
        },
        "repositoryReferenceName": {
          "type": "string",
          "example": "refs/heads/master",
          "description": "Reference name of a Git repository hosting the Stack file"
        },
        "repositoryURL": {
          "type": "string",
          "example": "https://github.com/openfaas/faas",
          "description": "URL of a Git repository hosting the Stack file"
        },
        "repositoryUsername": {
          "type": "string",
          "example": "myGitUsername",
          "description": "Username used in basic authentication. Required when RepositoryAuthentication is true\nand RepositoryGitCredentialID is 0"
        },
        "title": {
          "type": "string",
          "example": "Nginx",
          "description": "Title of the template"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)"
        },
        "variables": {
          "type": "array",
          "description": "Definitions of variables in the stack file",
          "items": {
            "$ref": "#/definitions/portainer.CustomTemplateVariableDefinition"
          }
        }
      }
    },
    "customtemplates.fileResponse": {
      "type": "object",
      "properties": {
        "fileContent": {
          "type": "string"
        }
      }
    },
    "docker.ContainerStats": {
      "type": "object",
      "properties": {
        "healthy": {
          "type": "integer"
        },
        "running": {
          "type": "integer"
        },
        "stopped": {
          "type": "integer"
        },
        "total": {
          "type": "integer"
        },
        "unhealthy": {
          "type": "integer"
        }
      }
    },
    "docker.dashboardResponse": {
      "type": "object",
      "properties": {
        "containers": {
          "$ref": "#/definitions/docker.ContainerStats"
        },
        "images": {
          "$ref": "#/definitions/docker.imagesCounters"
        },
        "networks": {
          "type": "integer"
        },
        "services": {
          "type": "integer"
        },
        "stacks": {
          "type": "integer"
        },
        "volumes": {
          "type": "integer"
        }
      }
    },
    "docker.imagesCounters": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer"
        },
        "total": {
          "type": "integer"
        }
      }
    },
    "edge.DeployerOptionsPayload": {
      "type": "object",
      "properties": {
        "prune": {
          "type": "boolean",
          "description": "Prune is a flag indicating if the agent must prune the containers or not when creating/updating an edge stack\nThis flag drives `docker compose up --remove-orphans` and `docker stack up --prune` options\nUsed only for EE"
        },
        "removeVolumes": {
          "type": "boolean",
          "description": "RemoveVolumes is a flag indicating if the agent must remove the named volumes declared\nin the compose file and anonymouse volumes attached to containers\nThis flag drives `docker compose down --volumes` option\nUsed only for EE"
        }
      }
    },
    "edge.RegistryCredentials": {
      "type": "object",
      "properties": {
        "secret": {
          "type": "string"
        },
        "serverURL": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      }
    },
    "edge.StackPayload": {
      "type": "object",
      "properties": {
        "deployerOptionsPayload": {
          "$ref": "#/definitions/edge.DeployerOptionsPayload"
        },
        "dirEntries": {
          "type": "array",
          "description": "Content of stack folder",
          "items": {
            "$ref": "#/definitions/filesystem.DirEntry"
          }
        },
        "edgeUpdateID": {
          "type": "integer",
          "description": "EdgeUpdateID is the ID of the edge update related to this stack.\nUsed only for EE"
        },
        "entryFileName": {
          "type": "string",
          "description": "Name of the stack entry file"
        },
        "envVars": {
          "type": "array",
          "description": "Used only for EE\nEnvVars is a list of environment variables to inject into the stack",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "filesystemPath": {
          "type": "string",
          "description": "Mount point for relative path"
        },
        "id": {
          "type": "integer",
          "description": "ID of the stack"
        },
        "name": {
          "type": "string",
          "description": "Name of the stack"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace to use for kubernetes stack. Keep empty to use the manifest namespace."
        },
        "prePullImage": {
          "type": "boolean",
          "description": "PrePullImage is a flag indicating if the agent must pull the image before deploying the stack.\nUsed only for EE"
        },
        "rePullImage": {
          "type": "boolean",
          "description": "RePullImage is a flag indicating if the agent must pull the image if it is already present on the node.\nUsed only for EE"
        },
        "readyRePullImage": {
          "type": "boolean",
          "description": "Used only for EE async edge agent\nReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image"
        },
        "registryCredentials": {
          "type": "array",
          "description": "RegistryCredentials holds the credentials for a Docker registry.\nUsed only for EE",
          "items": {
            "$ref": "#/definitions/edge.RegistryCredentials"
          }
        },
        "retryDeploy": {
          "type": "boolean",
          "description": "RetryDeploy is a flag indicating if the agent must retry to deploy the stack if it fails.\nUsed only for EE"
        },
        "retryPeriod": {
          "type": "integer",
          "description": "RetryPeriod specifies the duration, in seconds, for which the agent should continue attempting to deploy the stack after a failure\nUsed only for EE"
        },
        "rollbackTo": {
          "type": "integer",
          "description": "RollbackTo specifies the stack file version to rollback to (only support to rollback to the last version currently)"
        },
        "stackFileContent": {
          "type": "string",
          "description": "Content of the stack file (for compatibility to agent version less than 2.19.0)"
        },
        "supportRelativePath": {
          "type": "boolean",
          "description": "Is relative path supported"
        },
        "version": {
          "type": "integer",
          "description": "Version of the stack file"
        }
      }
    },
    "edgegroups.decoratedEdgeGroup": {
      "type": "object",
      "properties": {
        "Dynamic": {
          "type": "boolean"
        },
        "Endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "HasEdgeJob": {
          "type": "boolean"
        },
        "HasEdgeStack": {
          "type": "boolean"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "EdgeGroup Identifier"
        },
        "Name": {
          "type": "string"
        },
        "PartialMatch": {
          "type": "boolean"
        },
        "TagIds": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        },
        "TrustedEndpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "endpointTypes": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint)."
          }
        }
      }
    },
    "edgegroups.edgeGroupCreatePayload": {
      "type": "object",
      "properties": {
        "dynamic": {
          "type": "boolean"
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "name": {
          "type": "string"
        },
        "partialMatch": {
          "type": "boolean"
        },
        "tagIDs": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        }
      }
    },
    "edgegroups.edgeGroupUpdatePayload": {
      "type": "object",
      "properties": {
        "dynamic": {
          "type": "boolean"
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "name": {
          "type": "string"
        },
        "partialMatch": {
          "type": "boolean"
        },
        "tagIDs": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        }
      }
    },
    "edgejobs.edgeJobCreateFromFileContentPayload": {
      "type": "object",
      "properties": {
        "cronExpression": {
          "type": "string"
        },
        "edgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "fileContent": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "recurring": {
          "type": "boolean"
        }
      }
    },
    "edgejobs.edgeJobFileResponse": {
      "type": "object",
      "properties": {
        "FileContent": {
          "type": "string"
        }
      }
    },
    "edgejobs.edgeJobUpdatePayload": {
      "type": "object",
      "properties": {
        "cronExpression": {
          "type": "string"
        },
        "edgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "fileContent": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "recurring": {
          "type": "boolean"
        }
      }
    },
    "edgejobs.fileResponse": {
      "type": "object",
      "properties": {
        "FileContent": {
          "type": "string"
        }
      }
    },
    "edgejobs.taskContainer": {
      "type": "object",
      "properties": {
        "EndpointId": {
          "type": "integer"
        },
        "Id": {
          "type": "string"
        },
        "LogsStatus": {
          "type": "integer"
        }
      }
    },
    "edgestacks.edgeStackFromGitRepositoryPayload": {
      "type": "object",
      "required": [
        "edgeGroups",
        "name",
        "repositoryURL"
      ],
      "properties": {
        "deploymentType": {
          "type": "integer",
          "example": 0,
          "description": "Deployment type to deploy this stack\nValid values are: 0 - 'compose', 1 - 'kubernetes'\ncompose is enabled only for docker environments\nkubernetes is enabled only for kubernetes environments"
        },
        "edgeGroups": {
          "type": "array",
          "example": [
            1
          ],
          "description": "List of identifiers of EdgeGroups",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "filePathInRepository": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file inside the Git repository",
          "default": "docker-compose.yml"
        },
        "name": {
          "type": "string",
          "example": "stack-name",
          "description": "Name of the stack\nMax length: 255\nName must only contains lowercase characters, numbers, hyphens, or underscores\nName must start with a lowercase character or number\nExample: stack-name or stack_123 or stackName"
        },
        "registries": {
          "type": "array",
          "description": "List of Registries to use for this stack",
          "items": {
            "type": "integer",
            "description": "Registry Identifier"
          }
        },
        "repositoryAuthentication": {
          "type": "boolean",
          "example": true,
          "description": "Use basic authentication to clone the Git repository"
        },
        "repositoryPassword": {
          "type": "string",
          "example": "myGitPassword",
          "description": "Password used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "repositoryReferenceName": {
          "type": "string",
          "example": "refs/heads/master",
          "description": "Reference name of a Git repository hosting the Stack file"
        },
        "repositoryURL": {
          "type": "string",
          "example": "https://github.com/openfaas/faas",
          "description": "URL of a Git repository hosting the Stack file"
        },
        "repositoryUsername": {
          "type": "string",
          "example": "myGitUsername",
          "description": "Username used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        },
        "useManifestNamespaces": {
          "type": "boolean",
          "description": "Uses the manifest's namespaces instead of the default one"
        }
      }
    },
    "edgestacks.edgeStackFromStringPayload": {
      "type": "object",
      "required": [
        "name",
        "stackFileContent"
      ],
      "properties": {
        "deploymentType": {
          "type": "integer",
          "example": 0,
          "description": "Deployment type to deploy this stack\nValid values are: 0 - 'compose', 1 - 'kubernetes'\ncompose is enabled only for docker environments\nkubernetes is enabled only for kubernetes environments"
        },
        "edgeGroups": {
          "type": "array",
          "example": [
            1
          ],
          "description": "List of identifiers of EdgeGroups",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "name": {
          "type": "string",
          "example": "stack-name",
          "description": "Name of the stack\nMax length: 255\nName must only contains lowercase characters, numbers, hyphens, or underscores\nName must start with a lowercase character or number\nExample: stack-name or stack_123 or stackName"
        },
        "registries": {
          "type": "array",
          "description": "List of Registries to use for this stack",
          "items": {
            "type": "integer",
            "description": "Registry Identifier"
          }
        },
        "stackFileContent": {
          "type": "string",
          "example": "version: 3\n services:\n web:\n image:nginx",
          "description": "Content of the Stack file"
        },
        "useManifestNamespaces": {
          "type": "boolean",
          "description": "Uses the manifest's namespaces instead of the default one"
        }
      }
    },
    "edgestacks.stackFileResponse": {
      "type": "object",
      "properties": {
        "StackFileContent": {
          "type": "string"
        }
      }
    },
    "edgestacks.updateEdgeStackPayload": {
      "type": "object",
      "properties": {
        "deploymentType": {
          "type": "integer",
          "example": 0,
          "description": "Deployment type to deploy this stack\nValid values are: 0 - 'compose', 1 - 'kubernetes'\ncompose is enabled only for docker environments\nkubernetes is enabled only for kubernetes environments"
        },
        "edgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "stackFileContent": {
          "type": "string"
        },
        "updateVersion": {
          "type": "boolean"
        },
        "useManifestNamespaces": {
          "type": "boolean",
          "description": "Uses the manifest's namespaces instead of the default one"
        }
      }
    },
    "edgestacks.updateStatusPayload": {
      "type": "object",
      "properties": {
        "endpointID": {
          "type": "integer"
        },
        "error": {
          "type": "string"
        },
        "status": {
          "type": "integer",
          "description": "Deprecated"
        },
        "time": {
          "type": "integer"
        },
        "version": {
          "type": "integer"
        }
      }
    },
    "endpointedge.edgeJobResponse": {
      "type": "object",
      "properties": {
        "CollectLogs": {
          "type": "boolean",
          "example": true,
          "description": "Whether to collect logs"
        },
        "CronExpression": {
          "type": "string",
          "example": "* * * * *",
          "description": "A cron expression to schedule this job"
        },
        "Id": {
          "type": "integer",
          "example": 2,
          "description": "EdgeJob Identifier"
        },
        "Script": {
          "type": "string",
          "example": "echo hello",
          "description": "Script to run"
        },
        "Version": {
          "type": "integer",
          "example": 2,
          "description": "Version of this EdgeJob"
        }
      }
    },
    "endpointedge.endpointEdgeStatusInspectResponse": {
      "type": "object",
      "properties": {
        "checkin": {
          "type": "integer",
          "example": 5,
          "description": "The current value of CheckinInterval"
        },
        "credentials": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "example": 8732,
          "description": "The tunnel port"
        },
        "schedules": {
          "type": "array",
          "description": "List of requests for jobs to run on the environment(endpoint)",
          "items": {
            "$ref": "#/definitions/endpointedge.edgeJobResponse"
          }
        },
        "stacks": {
          "type": "array",
          "description": "List of stacks to be deployed on the environments(endpoints)",
          "items": {
            "$ref": "#/definitions/endpointedge.stackStatusResponse"
          }
        },
        "status": {
          "type": "string",
          "example": "REQUIRED",
          "description": "Status represents the environment(endpoint) status"
        }
      }
    },
    "endpointedge.stackStatusResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "example": 1,
          "description": "EdgeStack Identifier"
        },
        "version": {
          "type": "integer",
          "example": 3,
          "description": "Version of this stack"
        }
      }
    },
    "endpointgroups.endpointGroupCreatePayload": {
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "associatedEndpoints": {
          "type": "array",
          "example": [
            1,
            3
          ],
          "description": "List of environment(endpoint) identifiers that will be part of this group",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "description": {
          "type": "string",
          "example": "description",
          "description": "Environment(Endpoint) group description"
        },
        "name": {
          "type": "string",
          "example": "my-environment-group",
          "description": "Environment(Endpoint) group name"
        },
        "tagIDs": {
          "type": "array",
          "example": [
            1,
            2
          ],
          "description": "List of tag identifiers to which this environment(endpoint) group is associated",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        }
      }
    },
    "endpointgroups.endpointGroupUpdatePayload": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "example": "description",
          "description": "Environment(Endpoint) group description"
        },
        "name": {
          "type": "string",
          "example": "my-environment-group",
          "description": "Environment(Endpoint) group name"
        },
        "tagIDs": {
          "type": "array",
          "example": [
            3,
            4
          ],
          "description": "List of tag identifiers associated to the environment(endpoint) group",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        },
        "teamAccessPolicies": {
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "userAccessPolicies": {
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        }
      }
    },
    "endpoints.dockerhubStatusResponse": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "integer",
          "description": "Daily limit"
        },
        "remaining": {
          "type": "integer",
          "description": "Remaiming images to pull"
        }
      }
    },
    "endpoints.endpointCreateGlobalKeyResponse": {
      "type": "object",
      "properties": {
        "endpointID": {
          "type": "integer",
          "description": "Environment(Endpoint) Identifier"
        }
      }
    },
    "endpoints.endpointDeleteBatchPartialResponse": {
      "type": "object",
      "properties": {
        "deleted": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        }
      }
    },
    "endpoints.endpointDeleteBatchPayload": {
      "type": "object",
      "properties": {
        "endpoints": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/endpoints.endpointDeleteRequest"
          }
        }
      }
    },
    "endpoints.endpointDeleteRequest": {
      "type": "object",
      "properties": {
        "deleteCluster": {
          "type": "boolean"
        },
        "id": {
          "type": "integer"
        }
      }
    },
    "endpoints.endpointSettingsUpdatePayload": {
      "type": "object",
      "properties": {
        "allowBindMountsForRegularUsers": {
          "type": "boolean",
          "example": false,
          "description": "Whether non-administrator should be able to use bind mounts when creating containers"
        },
        "allowContainerCapabilitiesForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use container capabilities"
        },
        "allowDeviceMappingForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use device mapping"
        },
        "allowHostNamespaceForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use the host pid"
        },
        "allowPrivilegedModeForRegularUsers": {
          "type": "boolean",
          "example": false,
          "description": "Whether non-administrator should be able to use privileged mode when creating containers"
        },
        "allowStackManagementForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to manage stacks"
        },
        "allowSysctlSettingForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use sysctl settings"
        },
        "allowVolumeBrowserForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to browse volumes"
        },
        "enableGPUManagement": {
          "type": "boolean",
          "example": false
        },
        "enableHostManagementFeatures": {
          "type": "boolean",
          "example": true,
          "description": "Whether host management features are enabled"
        },
        "gpus": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        }
      }
    },
    "endpoints.endpointUpdatePayload": {
      "type": "object",
      "properties": {
        "azureApplicationID": {
          "type": "string",
          "example": "eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4",
          "description": "Azure application ID"
        },
        "azureAuthenticationKey": {
          "type": "string",
          "example": "cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk=",
          "description": "Azure authentication key"
        },
        "azureTenantID": {
          "type": "string",
          "example": "34ddc78d-4fel-2358-8cc1-df84c8o839f5",
          "description": "Azure tenant ID"
        },
        "edgeCheckinInterval": {
          "type": "integer",
          "example": 5,
          "description": "The check in interval for edge agent (in seconds)"
        },
        "gpus": {
          "type": "array",
          "description": "GPUs information",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "groupID": {
          "type": "integer",
          "example": 1,
          "description": "Group identifier"
        },
        "kubernetes": {
          "description": "Associated Kubernetes data",
          "$ref": "#/definitions/portainer.KubernetesData"
        },
        "name": {
          "type": "string",
          "example": "my-environment",
          "description": "Name that will be used to identify this environment(endpoint)"
        },
        "publicURL": {
          "type": "string",
          "example": "docker.mydomain.tld:2375",
          "description": "URL or IP address where exposed containers will be reachable.\\\nDefaults to URL if not specified"
        },
        "status": {
          "type": "integer",
          "example": 1,
          "description": "The status of the environment(endpoint) (1 - up, 2 - down)"
        },
        "tagIDs": {
          "type": "array",
          "example": [
            1,
            2
          ],
          "description": "List of tag identifiers to which this environment(endpoint) is associated",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        },
        "teamAccessPolicies": {
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "tls": {
          "type": "boolean",
          "example": true,
          "description": "Require TLS to connect against this environment(endpoint)"
        },
        "tlsskipClientVerify": {
          "type": "boolean",
          "example": false,
          "description": "Skip client verification when using TLS"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "Skip server verification when using TLS"
        },
        "url": {
          "type": "string",
          "example": "docker.mydomain.tld:2375",
          "description": "URL or IP address of a Docker host"
        },
        "userAccessPolicies": {
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        }
      }
    },
    "endpoints.endpointUpdateRelationsPayload": {
      "type": "object",
      "properties": {
        "relations": {
          "type": "object",
          "additionalProperties": {
            "$ref": "endpoints.endpointUpdateRelationsPayload_relations"
          }
        }
      }
    },
    "endpoints.forceUpdateServicePayload": {
      "type": "object",
      "properties": {
        "pullImage": {
          "type": "boolean",
          "description": "PullImage if true will pull the image"
        },
        "serviceID": {
          "type": "string",
          "description": "ServiceId to update"
        }
      }
    },
    "endpoints.registryAccessPayload": {
      "type": "object",
      "properties": {
        "namespaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "teamAccessPolicies": {
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "userAccessPolicies": {
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        }
      }
    },
    "filesystem.DirEntry": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string"
        },
        "isFile": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "permissions": {
          "type": "integer"
        }
      }
    },
    "gitops.fileResponse": {
      "type": "object",
      "properties": {
        "fileContent": {
          "type": "string"
        }
      }
    },
    "gitops.repositoryFilePreviewPayload": {
      "type": "object",
      "required": [
        "repository"
      ],
      "properties": {
        "password": {
          "type": "string",
          "example": "myGitPassword"
        },
        "reference": {
          "type": "string",
          "example": "refs/heads/master"
        },
        "repository": {
          "type": "string",
          "example": "https://github.com/openfaas/faas"
        },
        "targetFile": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to file whose content will be read"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        },
        "username": {
          "type": "string",
          "example": "myGitUsername"
        }
      }
    },
    "gittypes.GitAuthentication": {
      "type": "object",
      "properties": {
        "gitCredentialID": {
          "type": "integer",
          "example": 0,
          "description": "Git credentials identifier when the value is not 0\nWhen the value is 0, Username and Password are set without using saved credential\nThis is introduced since 2.15.0"
        },
        "password": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      }
    },
    "gittypes.RepoConfig": {
      "type": "object",
      "properties": {
        "authentication": {
          "description": "Git credentials",
          "$ref": "#/definitions/gittypes.GitAuthentication"
        },
        "configFilePath": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to where the config file is in this url/refName"
        },
        "configHash": {
          "type": "string",
          "example": "bc4c183d756879ea4d173315338110b31004b8e0",
          "description": "Repository hash"
        },
        "referenceName": {
          "type": "string",
          "example": "refs/heads/branch_name",
          "description": "The reference name"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        },
        "url": {
          "type": "string",
          "example": "https://github.com/portainer/portainer.git",
          "description": "The repo url"
        }
      }
    },
    "helm.installChartPayload": {
      "type": "object",
      "properties": {
        "chart": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "repo": {
          "type": "string"
        },
        "values": {
          "type": "string"
        }
      }
    },
    "images.ImageResponse": {
      "type": "object",
      "properties": {
        "created": {
          "type": "integer"
        },
        "id": {
          "type": "string"
        },
        "nodeName": {
          "type": "string"
        },
        "size": {
          "type": "integer"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "used": {
          "type": "boolean",
          "description": "Used is true if the image is used by at least one container\nsupplied only when withUsage is true"
        }
      }
    },
    "intstr.IntOrString": {
      "type": "object",
      "properties": {
        "intVal": {
          "type": "integer"
        },
        "strVal": {
          "type": "string"
        },
        "type": {
          "type": "integer"
        }
      }
    },
    "kubernetes.Configuration": {
      "type": "object",
      "properties": {
        "ConfigurationOwner": {
          "type": "string"
        },
        "Data": {
          "type": "object",
          "additionalProperties": true
        },
        "Kind": {
          "type": "string"
        }
      }
    },
    "kubernetes.IngressRule": {
      "type": "object",
      "properties": {
        "Host": {
          "type": "string"
        },
        "IP": {
          "type": "string"
        },
        "Path": {
          "type": "string"
        },
        "TLS": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.TLSInfo"
          }
        }
      }
    },
    "kubernetes.K8sApplication": {
      "type": "object",
      "properties": {
        "ApplicationOwner": {
          "type": "string"
        },
        "ApplicationType": {
          "type": "string"
        },
        "Configurations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.Configuration"
          }
        },
        "Containers": {
          "type": "array",
          "items": {}
        },
        "CreationDate": {
          "type": "string"
        },
        "DeploymentType": {
          "type": "string"
        },
        "HorizontalPodAutoscaler": {
          "$ref": "#/definitions/v2.HorizontalPodAutoscaler"
        },
        "Id": {
          "type": "string"
        },
        "Image": {
          "type": "string"
        },
        "Kind": {
          "type": "string"
        },
        "Labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "LoadBalancerIPAddress": {
          "type": "string"
        },
        "MatchLabels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Metadata": {
          "$ref": "#/definitions/kubernetes.Metadata"
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "Pods": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.Pod"
          }
        },
        "PublishedPorts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.PublishedPort"
          }
        },
        "Resource": {
          "$ref": "#/definitions/kubernetes.K8sApplicationResource"
        },
        "ResourcePool": {
          "type": "string"
        },
        "RunningPodsCount": {
          "type": "integer"
        },
        "ServiceId": {
          "type": "string"
        },
        "ServiceName": {
          "type": "string"
        },
        "ServiceType": {
          "type": "string"
        },
        "Services": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1.Service"
          }
        },
        "StackId": {
          "type": "string"
        },
        "StackName": {
          "type": "string"
        },
        "Status": {
          "type": "string"
        },
        "TotalPodsCount": {
          "type": "integer"
        },
        "Uid": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sApplicationResource": {
      "type": "object",
      "properties": {
        "CpuLimit": {
          "type": "number"
        },
        "CpuRequest": {
          "type": "number"
        },
        "MemoryLimit": {
          "type": "integer"
        },
        "MemoryRequest": {
          "type": "integer"
        }
      }
    },
    "kubernetes.K8sClusterRole": {
      "type": "object",
      "properties": {
        "creationDate": {
          "type": "string"
        },
        "isSystem": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "kubernetes.K8sClusterRoleBinding": {
      "type": "object",
      "properties": {
        "creationDate": {
          "type": "string"
        },
        "isSystem": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "roleRef": {
          "$ref": "#/definitions/v1.RoleRef"
        },
        "subjects": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1.Subject"
          }
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "kubernetes.K8sConfigMap": {
      "type": "object",
      "properties": {
        "Annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "ConfigurationOwner": {
          "type": "string"
        },
        "ConfigurationOwnerId": {
          "type": "string"
        },
        "ConfigurationOwners": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sConfigurationOwnerResource"
          }
        },
        "CreationDate": {
          "type": "string"
        },
        "Data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "IsUsed": {
          "type": "boolean"
        },
        "Labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "UID": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sConfigurationOwnerResource": {
      "type": "object",
      "properties": {
        "Id": {
          "type": "string"
        },
        "Name": {
          "type": "string"
        },
        "ResourceKind": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sCronJob": {
      "type": "object",
      "properties": {
        "Command": {
          "type": "string"
        },
        "Id": {
          "type": "string"
        },
        "IsSystem": {
          "type": "boolean"
        },
        "Jobs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sJob"
          }
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "Schedule": {
          "type": "string"
        },
        "Suspend": {
          "type": "boolean"
        },
        "Timezone": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sCronJobDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sDashboard": {
      "type": "object",
      "properties": {
        "applicationsCount": {
          "type": "integer"
        },
        "configMapsCount": {
          "type": "integer"
        },
        "ingressesCount": {
          "type": "integer"
        },
        "namespacesCount": {
          "type": "integer"
        },
        "secretsCount": {
          "type": "integer"
        },
        "servicesCount": {
          "type": "integer"
        },
        "volumesCount": {
          "type": "integer"
        }
      }
    },
    "kubernetes.K8sIngressController": {
      "type": "object",
      "properties": {
        "Availability": {
          "type": "boolean"
        },
        "ClassName": {
          "type": "string"
        },
        "Name": {
          "type": "string"
        },
        "New": {
          "type": "boolean"
        },
        "Type": {
          "type": "string"
        },
        "Used": {
          "type": "boolean"
        }
      }
    },
    "kubernetes.K8sIngressDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sIngressInfo": {
      "type": "object",
      "properties": {
        "Annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "ClassName": {
          "type": "string"
        },
        "CreationDate": {
          "type": "string"
        },
        "Hosts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "Paths": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sIngressPath"
          }
        },
        "TLS": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sIngressTLS"
          }
        },
        "Type": {
          "type": "string"
        },
        "UID": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sIngressPath": {
      "type": "object",
      "properties": {
        "HasService": {
          "type": "boolean"
        },
        "Host": {
          "type": "string"
        },
        "IngressName": {
          "type": "string"
        },
        "Path": {
          "type": "string"
        },
        "PathType": {
          "type": "string"
        },
        "Port": {
          "type": "integer"
        },
        "ServiceName": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sIngressTLS": {
      "type": "object",
      "properties": {
        "Hosts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "SecretName": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sJob": {
      "type": "object",
      "properties": {
        "BackoffLimit": {
          "type": "integer"
        },
        "Command": {
          "type": "string"
        },
        "Completions": {
          "type": "integer"
        },
        "Container": {
          "$ref": "#/definitions/v1.Container"
        },
        "Duration": {
          "type": "string"
        },
        "FailedReason": {
          "type": "string"
        },
        "FinishTime": {
          "type": "string"
        },
        "Id": {
          "type": "string"
        },
        "IsSystem": {
          "type": "boolean"
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "PodName": {
          "type": "string"
        },
        "StartTime": {
          "type": "string"
        },
        "Status": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sJobDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sNamespaceDetails": {
      "type": "object",
      "properties": {
        "Annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Name": {
          "type": "string"
        },
        "Owner": {
          "type": "string"
        },
        "ResourceQuota": {
          "$ref": "#/definitions/kubernetes.K8sResourceQuota"
        }
      }
    },
    "kubernetes.K8sPersistentVolume": {
      "type": "object",
      "properties": {
        "accessModes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "capacity": {
          "$ref": "#/definitions/v1.ResourceList"
        },
        "claimRef": {
          "$ref": "#/definitions/v1.ObjectReference"
        },
        "csi": {
          "$ref": "#/definitions/v1.CSIPersistentVolumeSource"
        },
        "name": {
          "type": "string"
        },
        "persistentVolumeReclaimPolicy": {
          "type": "string"
        },
        "storageClassName": {
          "type": "string"
        },
        "volumeMode": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sPersistentVolumeClaim": {
      "type": "object",
      "properties": {
        "accessModes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "creationDate": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "owningApplications": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sApplication"
          }
        },
        "phase": {
          "type": "string"
        },
        "resourcesRequests": {
          "$ref": "#/definitions/v1.ResourceList"
        },
        "storage": {
          "type": "integer"
        },
        "storageClass": {
          "type": "string"
        },
        "volumeMode": {
          "type": "string"
        },
        "volumeName": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sResourceQuota": {
      "type": "object",
      "properties": {
        "cpu": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "memory": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sRole": {
      "type": "object",
      "properties": {
        "creationDate": {
          "type": "string"
        },
        "isSystem": {
          "type": "boolean",
          "description": "isSystem is true if prefixed with \"system:\" or exists in the kube-system namespace\nor is one of the portainer roles"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "kubernetes.K8sRoleBinding": {
      "type": "object",
      "properties": {
        "creationDate": {
          "type": "string"
        },
        "isSystem": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "roleRef": {
          "$ref": "#/definitions/v1.RoleRef"
        },
        "subjects": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1.Subject"
          }
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "kubernetes.K8sRoleBindingDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sRoleDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sSecret": {
      "type": "object",
      "properties": {
        "Annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "ConfigurationOwner": {
          "type": "string"
        },
        "ConfigurationOwnerId": {
          "type": "string"
        },
        "ConfigurationOwners": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sConfigurationOwnerResource"
          }
        },
        "CreationDate": {
          "type": "string"
        },
        "Data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "IsUsed": {
          "type": "boolean"
        },
        "Labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Name": {
          "type": "string"
        },
        "Namespace": {
          "type": "string"
        },
        "SecretType": {
          "type": "string"
        },
        "UID": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sServiceAccount": {
      "type": "object",
      "properties": {
        "creationDate": {
          "type": "string"
        },
        "isSystem": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "kubernetes.K8sServiceAccountDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sServiceDeleteRequests": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sServiceInfo": {
      "type": "object",
      "properties": {
        "allocateLoadBalancerNodePorts": {
          "type": "boolean"
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "applications": {
          "type": "array",
          "description": "serviceList screen",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sApplication"
          }
        },
        "clusterIPs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "creationDate": {
          "type": "string"
        },
        "externalIPs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "externalName": {
          "type": "string"
        },
        "ingressStatus": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sServiceIngress"
          }
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "ports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.K8sServicePort"
          }
        },
        "selector": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "type": {
          "type": "string"
        },
        "uid": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sServiceIngress": {
      "type": "object",
      "properties": {
        "Host": {
          "type": "string"
        },
        "IP": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sServicePort": {
      "type": "object",
      "properties": {
        "Name": {
          "type": "string"
        },
        "NodePort": {
          "type": "integer"
        },
        "Port": {
          "type": "integer"
        },
        "Protocol": {
          "type": "string"
        },
        "TargetPort": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sStorageClass": {
      "type": "object",
      "properties": {
        "allowVolumeExpansion": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "provisioner": {
          "type": "string"
        },
        "reclaimPolicy": {
          "type": "string"
        }
      }
    },
    "kubernetes.K8sVolumeInfo": {
      "type": "object",
      "properties": {
        "persistentVolume": {
          "$ref": "#/definitions/kubernetes.K8sPersistentVolume"
        },
        "persistentVolumeClaim": {
          "$ref": "#/definitions/kubernetes.K8sPersistentVolumeClaim"
        },
        "storageClass": {
          "$ref": "#/definitions/kubernetes.K8sStorageClass"
        }
      }
    },
    "kubernetes.Metadata": {
      "type": "object",
      "properties": {
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "kubernetes.Pod": {
      "type": "object",
      "properties": {
        "Status": {
          "type": "string"
        }
      }
    },
    "kubernetes.PublishedPort": {
      "type": "object",
      "properties": {
        "IngressRules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kubernetes.IngressRule"
          }
        },
        "Port": {
          "type": "integer"
        }
      }
    },
    "kubernetes.TLSInfo": {
      "type": "object",
      "properties": {
        "hosts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "kubernetes.namespacesToggleSystemPayload": {
      "type": "object",
      "properties": {
        "system": {
          "type": "boolean",
          "example": true,
          "description": "Toggle the system state of this namespace to true or false"
        }
      }
    },
    "ldap.checkPayload": {
      "type": "object",
      "properties": {
        "ldapsettings": {
          "$ref": "#/definitions/portainer.LDAPSettings"
        }
      }
    },
    "motd.motdResponse": {
      "type": "object",
      "properties": {
        "ContentLayout": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Hash": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "Message": {
          "type": "string"
        },
        "Style": {
          "type": "string"
        },
        "Title": {
          "type": "string"
        }
      }
    },
    "openamt.deviceActionPayload": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string"
        }
      }
    },
    "openamt.deviceFeaturesPayload": {
      "type": "object",
      "properties": {
        "features": {
          "$ref": "#/definitions/portainer.OpenAMTDeviceEnabledFeatures"
        }
      }
    },
    "openamt.openAMTConfigurePayload": {
      "type": "object",
      "properties": {
        "certFileContent": {
          "type": "string"
        },
        "certFileName": {
          "type": "string"
        },
        "certFilePassword": {
          "type": "string"
        },
        "domainName": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "mpspassword": {
          "type": "string"
        },
        "mpsserver": {
          "type": "string"
        },
        "mpsuser": {
          "type": "string"
        }
      }
    },
    "portainer.APIKey": {
      "type": "object",
      "properties": {
        "dateCreated": {
          "type": "integer",
          "description": "Unix timestamp (UTC) when the API key was created"
        },
        "description": {
          "type": "string",
          "example": "portainer-api-key"
        },
        "digest": {
          "type": "string",
          "description": "Digest represents SHA256 hash of the raw API key"
        },
        "id": {
          "type": "integer",
          "example": 1
        },
        "lastUsed": {
          "type": "integer",
          "description": "Unix timestamp (UTC) when the API key was last used"
        },
        "prefix": {
          "type": "string",
          "description": "API key identifier (7 char prefix)"
        },
        "userId": {
          "type": "integer",
          "example": 1,
          "description": "User Identifier"
        }
      }
    },
    "portainer.AccessPolicy": {
      "type": "object",
      "properties": {
        "RoleId": {
          "type": "integer",
          "example": 1,
          "description": "Role identifier. Reference the role that will be associated to this access policy"
        }
      }
    },
    "portainer.Authorizations": {
      "type": "object",
      "additionalProperties": {
        "type": "boolean"
      }
    },
    "portainer.AutoUpdateSettings": {
      "type": "object",
      "properties": {
        "forcePullImage": {
          "type": "boolean",
          "example": false,
          "description": "Pull latest image"
        },
        "forceUpdate": {
          "type": "boolean",
          "example": false,
          "description": "Force update ignores repo changes"
        },
        "interval": {
          "type": "string",
          "example": "1m30s",
          "description": "Auto update interval"
        },
        "jobID": {
          "type": "string",
          "example": "15",
          "description": "Autoupdate job id"
        },
        "webhook": {
          "type": "string",
          "example": "05de31a2-79fa-4644-9c12-faa67e5c49f0",
          "description": "A UUID generated from client"
        }
      }
    },
    "portainer.AzureCredentials": {
      "type": "object",
      "properties": {
        "ApplicationID": {
          "type": "string",
          "example": "eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4",
          "description": "Azure application ID"
        },
        "AuthenticationKey": {
          "type": "string",
          "example": "cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk=",
          "description": "Azure authentication key"
        },
        "TenantID": {
          "type": "string",
          "example": "34ddc78d-4fel-2358-8cc1-df84c8o839f5",
          "description": "Azure tenant ID"
        }
      }
    },
    "portainer.CustomTemplate": {
      "type": "object",
      "properties": {
        "CreatedByUserId": {
          "type": "integer",
          "example": 3,
          "description": "User identifier who created this template"
        },
        "Description": {
          "type": "string",
          "example": "High performance web server",
          "description": "Description of the template"
        },
        "EntryPoint": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file"
        },
        "GitConfig": {
          "$ref": "#/definitions/gittypes.RepoConfig"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "CustomTemplate Identifier"
        },
        "Logo": {
          "type": "string",
          "example": "https://portainer.io/img/logo.svg",
          "description": "URL of the template's logo"
        },
        "Note": {
          "type": "string",
          "example": "This is my <b>custom</b> template",
          "description": "A note that will be displayed in the UI. Supports HTML content"
        },
        "Platform": {
          "type": "integer",
          "example": 1,
          "description": "Platform associated to the template.\nValid values are: 1 - 'linux', 2 - 'windows'"
        },
        "ProjectPath": {
          "type": "string",
          "example": "/data/custom_template/3",
          "description": "Path on disk to the repository hosting the Stack file"
        },
        "ResourceControl": {
          "$ref": "#/definitions/portainer.ResourceControl"
        },
        "Title": {
          "type": "string",
          "example": "Nginx",
          "description": "Title of the template"
        },
        "Type": {
          "type": "integer",
          "example": 1,
          "description": "Type of created stack:\n* 1 - swarm\n* 2 - compose\n* 3 - kubernetes"
        },
        "edgeTemplate": {
          "type": "boolean",
          "example": false,
          "description": "EdgeTemplate indicates if this template purpose for Edge Stack"
        },
        "isComposeFormat": {
          "type": "boolean",
          "example": false,
          "description": "IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file"
        },
        "variables": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.CustomTemplateVariableDefinition"
          }
        }
      }
    },
    "portainer.CustomTemplateVariableDefinition": {
      "type": "object",
      "properties": {
        "defaultValue": {
          "type": "string",
          "example": "default value"
        },
        "description": {
          "type": "string",
          "example": "Description"
        },
        "label": {
          "type": "string",
          "example": "My Variable"
        },
        "name": {
          "type": "string",
          "example": "MY_VAR"
        }
      }
    },
    "portainer.DiagnosticsData": {
      "type": "object",
      "properties": {
        "DNS": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Log": {
          "type": "string"
        },
        "Proxy": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Telnet": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "portainer.DockerSnapshot": {
      "type": "object",
      "properties": {
        "ContainerCount": {
          "type": "integer"
        },
        "DiagnosticsData": {
          "$ref": "#/definitions/portainer.DiagnosticsData"
        },
        "DockerSnapshotRaw": {
          "$ref": "#/definitions/portainer.DockerSnapshotRaw"
        },
        "DockerVersion": {
          "type": "string"
        },
        "GpuUseAll": {
          "type": "boolean"
        },
        "GpuUseList": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "HealthyContainerCount": {
          "type": "integer"
        },
        "ImageCount": {
          "type": "integer"
        },
        "IsPodman": {
          "type": "boolean"
        },
        "NodeCount": {
          "type": "integer"
        },
        "RunningContainerCount": {
          "type": "integer"
        },
        "ServiceCount": {
          "type": "integer"
        },
        "StackCount": {
          "type": "integer"
        },
        "StoppedContainerCount": {
          "type": "integer"
        },
        "Swarm": {
          "type": "boolean"
        },
        "Time": {
          "type": "integer"
        },
        "TotalCPU": {
          "type": "integer"
        },
        "TotalMemory": {
          "type": "integer"
        },
        "UnhealthyContainerCount": {
          "type": "integer"
        },
        "VolumeCount": {
          "type": "integer"
        }
      }
    },
    "portainer.DockerSnapshotRaw": {
      "type": "object"
    },
    "portainer.EcrData": {
      "type": "object",
      "properties": {
        "Region": {
          "type": "string",
          "example": "ap-southeast-2"
        }
      }
    },
    "portainer.Edge": {
      "type": "object",
      "properties": {
        "AsyncMode": {
          "type": "boolean",
          "example": false,
          "description": "Deprecated 2.18"
        },
        "CommandInterval": {
          "type": "integer",
          "example": 5,
          "description": "The command list interval for edge agent - used in edge async mode (in seconds)"
        },
        "PingInterval": {
          "type": "integer",
          "example": 5,
          "description": "The ping interval for edge agent - used in edge async mode (in seconds)"
        },
        "SnapshotInterval": {
          "type": "integer",
          "example": 5,
          "description": "The snapshot interval for edge agent - used in edge async mode (in seconds)"
        }
      }
    },
    "portainer.EdgeGroup": {
      "type": "object",
      "properties": {
        "Dynamic": {
          "type": "boolean"
        },
        "Endpoints": {
          "type": "array",
          "items": {
            "type": "integer",
            "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
          }
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "EdgeGroup Identifier"
        },
        "Name": {
          "type": "string"
        },
        "PartialMatch": {
          "type": "boolean"
        },
        "TagIds": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        }
      }
    },
    "portainer.EdgeJob": {
      "type": "object",
      "properties": {
        "Created": {
          "type": "integer"
        },
        "CronExpression": {
          "type": "string"
        },
        "EdgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "Endpoints": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/portainer.EdgeJobEndpointMeta"
          }
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "EdgeJob Identifier"
        },
        "Name": {
          "type": "string"
        },
        "Recurring": {
          "type": "boolean"
        },
        "ScriptPath": {
          "type": "string"
        },
        "Version": {
          "type": "integer"
        },
        "groupLogsCollection": {
          "type": "object",
          "description": "Field used for log collection of Endpoints belonging to EdgeGroups",
          "additionalProperties": {
            "$ref": "#/definitions/portainer.EdgeJobEndpointMeta"
          }
        }
      }
    },
    "portainer.EdgeJobEndpointMeta": {
      "type": "object",
      "properties": {
        "collectLogs": {
          "type": "boolean"
        },
        "logsStatus": {
          "type": "integer"
        }
      }
    },
    "portainer.EdgeStack": {
      "type": "object",
      "properties": {
        "CreationDate": {
          "type": "integer",
          "description": "StatusArray    map[EndpointID][]EdgeStackStatus `json:\"StatusArray\"`"
        },
        "DeploymentType": {
          "type": "integer"
        },
        "EdgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "EntryPoint": {
          "type": "string"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "EdgeStack Identifier"
        },
        "ManifestPath": {
          "type": "string"
        },
        "Name": {
          "type": "string"
        },
        "NumDeployments": {
          "type": "integer"
        },
        "ProjectPath": {
          "type": "string"
        },
        "Status": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/portainer.EdgeStackStatus"
          }
        },
        "Version": {
          "type": "integer"
        },
        "useManifestNamespaces": {
          "type": "boolean",
          "description": "Uses the manifest's namespaces instead of the default one"
        }
      }
    },
    "portainer.EdgeStackDeploymentStatus": {
      "type": "object",
      "properties": {
        "Version": {
          "type": "integer"
        },
        "error": {
          "type": "string"
        },
        "rollbackTo": {
          "type": "integer",
          "description": "EE only feature"
        },
        "time": {
          "type": "integer"
        },
        "type": {
          "type": "integer"
        }
      }
    },
    "portainer.EdgeStackStatus": {
      "type": "object",
      "properties": {
        "Type": {
          "type": "integer",
          "description": "Deprecated"
        },
        "deploymentInfo": {
          "description": "EE only feature",
          "$ref": "#/definitions/portainer.StackDeploymentInfo"
        },
        "details": {
          "description": "Deprecated",
          "$ref": "#/definitions/portainer.EdgeStackStatusDetails"
        },
        "endpointID": {
          "type": "integer"
        },
        "error": {
          "type": "string",
          "description": "Deprecated"
        },
        "readyRePullImage": {
          "type": "boolean",
          "description": "ReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image"
        },
        "status": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.EdgeStackDeploymentStatus"
          }
        }
      }
    },
    "portainer.EdgeStackStatusDetails": {
      "type": "object",
      "properties": {
        "acknowledged": {
          "type": "boolean"
        },
        "error": {
          "type": "boolean"
        },
        "imagesPulled": {
          "type": "boolean"
        },
        "ok": {
          "type": "boolean"
        },
        "pending": {
          "type": "boolean"
        },
        "remoteUpdateSuccess": {
          "type": "boolean"
        },
        "remove": {
          "type": "boolean"
        }
      }
    },
    "portainer.Endpoint": {
      "type": "object",
      "properties": {
        "AMTDeviceGUID": {
          "type": "string",
          "example": "4c4c4544-004b-3910-8037-b6c04f504633",
          "description": "The identifier of the AMT Device associated with this environment(endpoint)"
        },
        "AuthorizedTeams": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Team Identifier"
          }
        },
        "AuthorizedUsers": {
          "type": "array",
          "description": "Deprecated in DBVersion == 18",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "User identifier"
          }
        },
        "AzureCredentials": {
          "$ref": "#/definitions/portainer.AzureCredentials"
        },
        "ComposeSyntaxMaxVersion": {
          "type": "string",
          "example": "3.8",
          "description": "Maximum version of docker-compose"
        },
        "ContainerEngine": {
          "type": "string",
          "example": "docker",
          "description": "ContainerEngine represents the container engine type. This can be 'docker' or 'podman' when interacting directly with these environmentes, otherwise '' for kubernetes environments."
        },
        "EdgeCheckinInterval": {
          "type": "integer",
          "example": 5,
          "description": "The check in interval for edge agent (in seconds)"
        },
        "EdgeID": {
          "type": "string",
          "description": "The identifier of the edge agent associated with this environment(endpoint)"
        },
        "EdgeKey": {
          "type": "string",
          "description": "The key which is used to map the agent to Portainer"
        },
        "EnableGPUManagement": {
          "type": "boolean"
        },
        "Gpus": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "GroupId": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) group identifier"
        },
        "Heartbeat": {
          "type": "boolean",
          "example": true,
          "description": "Heartbeat indicates the heartbeat status of an edge environment"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) Identifier"
        },
        "IsEdgeDevice": {
          "type": "boolean",
          "description": "Deprecated v2.18"
        },
        "Kubernetes": {
          "description": "Associated Kubernetes data",
          "$ref": "#/definitions/portainer.KubernetesData"
        },
        "Name": {
          "type": "string",
          "example": "my-environment",
          "description": "Environment(Endpoint) name"
        },
        "PostInitMigrations": {
          "description": "Whether we need to run any \"post init migrations\".",
          "$ref": "#/definitions/portainer.EndpointPostInitMigrations"
        },
        "PublicURL": {
          "type": "string",
          "example": "docker.mydomain.tld:2375",
          "description": "URL or IP address where exposed containers will be reachable"
        },
        "Snapshots": {
          "type": "array",
          "description": "List of snapshots",
          "items": {
            "$ref": "#/definitions/portainer.DockerSnapshot"
          }
        },
        "Status": {
          "type": "integer",
          "example": 1,
          "description": "The status of the environment(endpoint) (1 - up, 2 - down)"
        },
        "TLS": {
          "type": "boolean",
          "description": "Deprecated fields\nDeprecated in DBVersion == 4"
        },
        "TLSCACert": {
          "type": "string"
        },
        "TLSCert": {
          "type": "string"
        },
        "TLSConfig": {
          "$ref": "#/definitions/portainer.TLSConfiguration"
        },
        "TLSKey": {
          "type": "string"
        },
        "TagIds": {
          "type": "array",
          "description": "List of tag identifiers to which this environment(endpoint) is associated",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        },
        "Tags": {
          "type": "array",
          "description": "Deprecated in DBVersion == 22",
          "items": {
            "type": "string"
          }
        },
        "TeamAccessPolicies": {
          "description": "List of team identifiers authorized to connect to this environment(endpoint)",
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "Type": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint)."
        },
        "URL": {
          "type": "string",
          "example": "docker.mydomain.tld:2375",
          "description": "URL or IP address of the Docker host associated to this environment(endpoint)"
        },
        "UserAccessPolicies": {
          "description": "List of user identifiers authorized to connect to this environment(endpoint)",
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        },
        "UserTrusted": {
          "type": "boolean",
          "description": "Whether the device has been trusted or not by the user"
        },
        "agent": {
          "$ref": "portainer.Endpoint_agent"
        },
        "edge": {
          "$ref": "#/definitions/portainer.EnvironmentEdgeSettings"
        },
        "lastCheckInDate": {
          "type": "integer",
          "description": "LastCheckInDate mark last check-in date on checkin"
        },
        "queryDate": {
          "type": "integer",
          "description": "QueryDate of each query with the endpoints list"
        },
        "securitySettings": {
          "description": "Environment(Endpoint) specific security settings",
          "$ref": "#/definitions/portainer.EndpointSecuritySettings"
        }
      }
    },
    "portainer.EndpointAuthorizations": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/portainer.Authorizations"
      }
    },
    "portainer.EndpointGroup": {
      "type": "object",
      "properties": {
        "AuthorizedTeams": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Team Identifier"
          }
        },
        "AuthorizedUsers": {
          "type": "array",
          "description": "Deprecated in DBVersion == 18",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "User identifier"
          }
        },
        "Description": {
          "type": "string",
          "example": "Environment(Endpoint) group description",
          "description": "Description associated to the environment(endpoint) group"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) group Identifier"
        },
        "Labels": {
          "type": "array",
          "description": "Deprecated fields",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "Name": {
          "type": "string",
          "example": "my-environment-group",
          "description": "Environment(Endpoint) group name"
        },
        "TagIds": {
          "type": "array",
          "description": "List of tags associated to this environment(endpoint) group",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        },
        "Tags": {
          "type": "array",
          "description": "Deprecated in DBVersion == 22",
          "items": {
            "type": "string"
          }
        },
        "TeamAccessPolicies": {
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "UserAccessPolicies": {
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        }
      }
    },
    "portainer.EndpointPostInitMigrations": {
      "type": "object",
      "properties": {
        "MigrateGPUs": {
          "type": "boolean"
        },
        "MigrateIngresses": {
          "type": "boolean"
        }
      }
    },
    "portainer.EndpointSecuritySettings": {
      "type": "object",
      "properties": {
        "allowBindMountsForRegularUsers": {
          "type": "boolean",
          "example": false,
          "description": "Whether non-administrator should be able to use bind mounts when creating containers"
        },
        "allowContainerCapabilitiesForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use container capabilities"
        },
        "allowDeviceMappingForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use device mapping"
        },
        "allowHostNamespaceForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use the host pid"
        },
        "allowPrivilegedModeForRegularUsers": {
          "type": "boolean",
          "example": false,
          "description": "Whether non-administrator should be able to use privileged mode when creating containers"
        },
        "allowStackManagementForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to manage stacks"
        },
        "allowSysctlSettingForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to use sysctl settings"
        },
        "allowVolumeBrowserForRegularUsers": {
          "type": "boolean",
          "example": true,
          "description": "Whether non-administrator should be able to browse volumes"
        },
        "enableHostManagementFeatures": {
          "type": "boolean",
          "example": true,
          "description": "Whether host management features are enabled"
        }
      }
    },
    "portainer.EnvironmentEdgeSettings": {
      "type": "object",
      "properties": {
        "CommandInterval": {
          "type": "integer",
          "example": 60,
          "description": "The command list interval for edge agent - used in edge async mode [seconds]"
        },
        "PingInterval": {
          "type": "integer",
          "example": 60,
          "description": "The ping interval for edge agent - used in edge async mode [seconds]"
        },
        "SnapshotInterval": {
          "type": "integer",
          "example": 60,
          "description": "The snapshot interval for edge agent - used in edge async mode [seconds]"
        },
        "asyncMode": {
          "type": "boolean",
          "description": "Whether the device has been started in edge async mode"
        }
      }
    },
    "portainer.GitlabRegistryData": {
      "type": "object",
      "properties": {
        "InstanceURL": {
          "type": "string"
        },
        "ProjectId": {
          "type": "integer"
        },
        "ProjectPath": {
          "type": "string"
        }
      }
    },
    "portainer.GlobalDeploymentOptions": {
      "type": "object",
      "properties": {
        "hideStacksFunctionality": {
          "type": "boolean",
          "example": false
        }
      }
    },
    "portainer.HelmUserRepository": {
      "type": "object",
      "properties": {
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Membership Identifier"
        },
        "URL": {
          "type": "string",
          "example": "https://kubernetes.github.io/ingress-nginx",
          "description": "Helm repository URL"
        },
        "UserId": {
          "type": "integer",
          "example": 1,
          "description": "User identifier"
        }
      }
    },
    "portainer.InternalAuthSettings": {
      "type": "object",
      "properties": {
        "requiredPasswordLength": {
          "type": "integer"
        }
      }
    },
    "portainer.K8sNamespaceInfo": {
      "type": "object",
      "properties": {
        "Annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "CreationDate": {
          "type": "string"
        },
        "Id": {
          "type": "string"
        },
        "IsDefault": {
          "type": "boolean"
        },
        "IsSystem": {
          "type": "boolean"
        },
        "Name": {
          "type": "string"
        },
        "NamespaceOwner": {
          "type": "string"
        },
        "ResourceQuota": {
          "$ref": "#/definitions/v1.ResourceQuota"
        },
        "Status": {
          "$ref": "#/definitions/v1.NamespaceStatus"
        }
      }
    },
    "portainer.K8sNodeLimits": {
      "type": "object",
      "properties": {
        "CPU": {
          "type": "integer"
        },
        "Memory": {
          "type": "integer"
        }
      }
    },
    "portainer.K8sNodesLimits": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/portainer.K8sNodeLimits"
      }
    },
    "portainer.KubernetesConfiguration": {
      "type": "object",
      "properties": {
        "AllowNoneIngressClass": {
          "type": "boolean"
        },
        "EnableResourceOverCommit": {
          "type": "boolean"
        },
        "IngressAvailabilityPerNamespace": {
          "type": "boolean"
        },
        "IngressClasses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.KubernetesIngressClassConfig"
          }
        },
        "ResourceOverCommitPercentage": {
          "type": "integer"
        },
        "RestrictDefaultNamespace": {
          "type": "boolean"
        },
        "StorageClasses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.KubernetesStorageClassConfig"
          }
        },
        "UseLoadBalancer": {
          "type": "boolean"
        },
        "UseServerMetrics": {
          "type": "boolean"
        }
      }
    },
    "portainer.KubernetesData": {
      "type": "object",
      "properties": {
        "Configuration": {
          "$ref": "#/definitions/portainer.KubernetesConfiguration"
        },
        "Flags": {
          "$ref": "#/definitions/portainer.KubernetesFlags"
        },
        "Snapshots": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.KubernetesSnapshot"
          }
        }
      }
    },
    "portainer.KubernetesFlags": {
      "type": "object",
      "properties": {
        "IsServerIngressClassDetected": {
          "type": "boolean"
        },
        "IsServerMetricsDetected": {
          "type": "boolean"
        },
        "IsServerStorageDetected": {
          "type": "boolean"
        }
      }
    },
    "portainer.KubernetesIngressClassConfig": {
      "type": "object",
      "properties": {
        "Blocked": {
          "type": "boolean"
        },
        "BlockedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Name": {
          "type": "string"
        },
        "Type": {
          "type": "string"
        }
      }
    },
    "portainer.KubernetesSnapshot": {
      "type": "object",
      "properties": {
        "DiagnosticsData": {
          "$ref": "#/definitions/portainer.DiagnosticsData"
        },
        "KubernetesVersion": {
          "type": "string"
        },
        "NodeCount": {
          "type": "integer"
        },
        "Time": {
          "type": "integer"
        },
        "TotalCPU": {
          "type": "integer"
        },
        "TotalMemory": {
          "type": "integer"
        }
      }
    },
    "portainer.KubernetesStorageClassConfig": {
      "type": "object",
      "properties": {
        "AccessModes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "AllowVolumeExpansion": {
          "type": "boolean"
        },
        "Name": {
          "type": "string"
        },
        "Provisioner": {
          "type": "string"
        }
      }
    },
    "portainer.LDAPGroupSearchSettings": {
      "type": "object",
      "properties": {
        "GroupAttribute": {
          "type": "string",
          "example": "member",
          "description": "LDAP attribute which denotes the group membership"
        },
        "GroupBaseDN": {
          "type": "string",
          "example": "dc=ldap,dc=domain,dc=tld",
          "description": "The distinguished name of the element from which the LDAP server will search for groups"
        },
        "GroupFilter": {
          "type": "string",
          "example": "(objectClass=account",
          "description": "The LDAP search filter used to select group elements, optional"
        }
      }
    },
    "portainer.LDAPSearchSettings": {
      "type": "object",
      "properties": {
        "BaseDN": {
          "type": "string",
          "example": "dc=ldap,dc=domain,dc=tld",
          "description": "The distinguished name of the element from which the LDAP server will search for users"
        },
        "Filter": {
          "type": "string",
          "example": "(objectClass=account)",
          "description": "Optional LDAP search filter used to select user elements"
        },
        "UserNameAttribute": {
          "type": "string",
          "example": "uid",
          "description": "LDAP attribute which denotes the username"
        }
      }
    },
    "portainer.LDAPSettings": {
      "type": "object",
      "properties": {
        "AnonymousMode": {
          "type": "boolean",
          "example": true,
          "description": "Enable this option if the server is configured for Anonymous access. When enabled, ReaderDN and Password will not be used"
        },
        "AutoCreateUsers": {
          "type": "boolean",
          "example": true,
          "description": "Automatically provision users and assign them to matching LDAP group names"
        },
        "GroupSearchSettings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.LDAPGroupSearchSettings"
          }
        },
        "Password": {
          "type": "string",
          "example": "readonly-password",
          "description": "Password of the account that will be used to search users"
        },
        "ReaderDN": {
          "type": "string",
          "example": "cn=readonly-account,dc=ldap,dc=domain,dc=tld",
          "description": "Account that will be used to search for users"
        },
        "SearchSettings": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.LDAPSearchSettings"
          }
        },
        "StartTLS": {
          "type": "boolean",
          "example": true,
          "description": "Whether LDAP connection should use StartTLS"
        },
        "TLSConfig": {
          "$ref": "#/definitions/portainer.TLSConfiguration"
        },
        "URL": {
          "type": "string",
          "example": "myldap.domain.tld:389",
          "description": "URL or IP address of the LDAP server"
        }
      }
    },
    "portainer.OAuthSettings": {
      "type": "object",
      "properties": {
        "AccessTokenURI": {
          "type": "string"
        },
        "AuthStyle": {
          "type": "integer"
        },
        "AuthorizationURI": {
          "type": "string"
        },
        "ClientID": {
          "type": "string"
        },
        "ClientSecret": {
          "type": "string"
        },
        "DefaultTeamID": {
          "type": "integer"
        },
        "KubeSecretKey": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "LogoutURI": {
          "type": "string"
        },
        "OAuthAutoCreateUsers": {
          "type": "boolean"
        },
        "RedirectURI": {
          "type": "string"
        },
        "ResourceURI": {
          "type": "string"
        },
        "SSO": {
          "type": "boolean"
        },
        "Scopes": {
          "type": "string"
        },
        "UserIdentifier": {
          "type": "string"
        }
      }
    },
    "portainer.OpenAMTConfiguration": {
      "type": "object",
      "properties": {
        "certFileContent": {
          "type": "string"
        },
        "certFileName": {
          "type": "string"
        },
        "certFilePassword": {
          "type": "string"
        },
        "domainName": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        },
        "mpsPassword": {
          "type": "string"
        },
        "mpsServer": {
          "type": "string"
        },
        "mpsToken": {
          "type": "string",
          "description": "retrieved from API"
        },
        "mpsUser": {
          "type": "string"
        }
      }
    },
    "portainer.OpenAMTDeviceEnabledFeatures": {
      "type": "object",
      "properties": {
        "IDER": {
          "type": "boolean"
        },
        "KVM": {
          "type": "boolean"
        },
        "SOL": {
          "type": "boolean"
        },
        "redirection": {
          "type": "boolean"
        },
        "userConsent": {
          "type": "string"
        }
      }
    },
    "portainer.Pair": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "name"
        },
        "value": {
          "type": "string",
          "example": "value"
        }
      }
    },
    "portainer.QuayRegistryData": {
      "type": "object",
      "properties": {
        "OrganisationName": {
          "type": "string"
        },
        "UseOrganisation": {
          "type": "boolean"
        }
      }
    },
    "portainer.Registry": {
      "type": "object",
      "properties": {
        "AccessToken": {
          "type": "string",
          "description": "Stores temporary access token"
        },
        "AccessTokenExpiry": {
          "type": "integer"
        },
        "Authentication": {
          "type": "boolean",
          "example": true,
          "description": "Is authentication against this registry enabled"
        },
        "AuthorizedTeams": {
          "type": "array",
          "description": "Deprecated in DBVersion == 18",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Team Identifier"
          }
        },
        "AuthorizedUsers": {
          "type": "array",
          "description": "Deprecated in DBVersion == 18",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "User identifier"
          }
        },
        "BaseURL": {
          "type": "string",
          "example": "registry.mydomain.tld:2375",
          "description": "Base URL, introduced for ProGet registry"
        },
        "Ecr": {
          "$ref": "#/definitions/portainer.EcrData"
        },
        "Gitlab": {
          "$ref": "#/definitions/portainer.GitlabRegistryData"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Registry Identifier"
        },
        "ManagementConfiguration": {
          "$ref": "#/definitions/portainer.RegistryManagementConfiguration"
        },
        "Name": {
          "type": "string",
          "example": "my-registry",
          "description": "Registry Name"
        },
        "Password": {
          "type": "string",
          "example": "registry_password",
          "description": "Password or SecretAccessKey used to authenticate against this registry"
        },
        "Quay": {
          "$ref": "#/definitions/portainer.QuayRegistryData"
        },
        "RegistryAccesses": {
          "$ref": "#/definitions/portainer.RegistryAccesses"
        },
        "TeamAccessPolicies": {
          "description": "Deprecated in DBVersion == 31",
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "Type": {
          "type": "integer",
          "description": "Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)"
        },
        "URL": {
          "type": "string",
          "example": "registry.mydomain.tld:2375",
          "description": "URL or IP address of the Docker registry"
        },
        "UserAccessPolicies": {
          "description": "Deprecated fields\nDeprecated in DBVersion == 31",
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        },
        "Username": {
          "type": "string",
          "example": "registry user",
          "description": "Username or AccessKeyID used to authenticate against this registry"
        }
      }
    },
    "portainer.RegistryAccessPolicies": {
      "type": "object",
      "properties": {
        "Namespaces": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "TeamAccessPolicies": {
          "$ref": "#/definitions/portainer.TeamAccessPolicies"
        },
        "UserAccessPolicies": {
          "$ref": "#/definitions/portainer.UserAccessPolicies"
        }
      }
    },
    "portainer.RegistryAccesses": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/portainer.RegistryAccessPolicies"
      }
    },
    "portainer.RegistryManagementConfiguration": {
      "type": "object",
      "properties": {
        "AccessToken": {
          "type": "string"
        },
        "AccessTokenExpiry": {
          "type": "integer"
        },
        "Authentication": {
          "type": "boolean"
        },
        "Ecr": {
          "$ref": "#/definitions/portainer.EcrData"
        },
        "Password": {
          "type": "string"
        },
        "TLSConfig": {
          "$ref": "#/definitions/portainer.TLSConfiguration"
        },
        "Type": {
          "type": "integer",
          "description": "Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)"
        },
        "Username": {
          "type": "string"
        }
      }
    },
    "portainer.ResourceControl": {
      "type": "object",
      "properties": {
        "AccessLevel": {
          "type": "integer"
        },
        "AdministratorsOnly": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to resource only to admins"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "ResourceControl Identifier"
        },
        "OwnerId": {
          "type": "integer",
          "description": "Deprecated fields\nDeprecated in DBVersion == 2"
        },
        "Public": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to the associated resource to any user"
        },
        "ResourceId": {
          "type": "string",
          "example": "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08",
          "description": "Docker resource identifier on which access control will be applied.\\\nIn the case of a resource control applied to a stack, use the stack name as identifier"
        },
        "SubResourceIds": {
          "type": "array",
          "example": [
            "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
          ],
          "description": "List of Docker resources that will inherit this access control",
          "items": {
            "type": "string"
          }
        },
        "System": {
          "type": "boolean"
        },
        "TeamAccesses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.TeamResourceAccess"
          }
        },
        "Type": {
          "type": "integer",
          "example": 1,
          "description": "Type of Docker resource. Valid values are: 1- container, 2 -service\n3 - volume, 4 - secret, 5 - stack, 6 - config or 7 - custom template"
        },
        "UserAccesses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.UserResourceAccess"
          }
        }
      }
    },
    "portainer.Role": {
      "type": "object",
      "properties": {
        "Authorizations": {
          "description": "Authorizations associated to a role",
          "$ref": "#/definitions/portainer.Authorizations"
        },
        "Description": {
          "type": "string",
          "example": "Read-only access of all resources in an environment(endpoint)",
          "description": "Role description"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Role Identifier"
        },
        "Name": {
          "type": "string",
          "example": "HelpDesk",
          "description": "Role name"
        },
        "Priority": {
          "type": "integer"
        }
      }
    },
    "portainer.SSLSettings": {
      "type": "object",
      "properties": {
        "certPath": {
          "type": "string"
        },
        "httpEnabled": {
          "type": "boolean"
        },
        "keyPath": {
          "type": "string"
        },
        "selfSigned": {
          "type": "boolean"
        }
      }
    },
    "portainer.Settings": {
      "type": "object",
      "properties": {
        "AgentSecret": {
          "type": "string",
          "description": "Container environment parameter AGENT_SECRET"
        },
        "AllowBindMountsForRegularUsers": {
          "type": "boolean"
        },
        "AllowContainerCapabilitiesForRegularUsers": {
          "type": "boolean"
        },
        "AllowDeviceMappingForRegularUsers": {
          "type": "boolean"
        },
        "AllowHostNamespaceForRegularUsers": {
          "type": "boolean"
        },
        "AllowPrivilegedModeForRegularUsers": {
          "type": "boolean"
        },
        "AllowStackManagementForRegularUsers": {
          "type": "boolean"
        },
        "AllowVolumeBrowserForRegularUsers": {
          "type": "boolean"
        },
        "AuthenticationMethod": {
          "type": "integer",
          "example": 1,
          "description": "Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth"
        },
        "BlackListedLabels": {
          "type": "array",
          "description": "A list of label name & value that will be used to hide containers when querying containers",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "DisplayDonationHeader": {
          "type": "boolean",
          "description": "Deprecated fields"
        },
        "DisplayExternalContributors": {
          "type": "boolean"
        },
        "Edge": {
          "$ref": "#/definitions/portainer.Edge"
        },
        "EdgeAgentCheckinInterval": {
          "type": "integer",
          "example": 5,
          "description": "The default check in interval for edge agent (in seconds)"
        },
        "EdgePortainerUrl": {
          "type": "string",
          "description": "EdgePortainerURL is the URL that is exposed to edge agents"
        },
        "EnableEdgeComputeFeatures": {
          "type": "boolean",
          "description": "Whether edge compute features are enabled"
        },
        "EnableHostManagementFeatures": {
          "type": "boolean",
          "description": "Deprecated fields v26"
        },
        "EnableTelemetry": {
          "type": "boolean",
          "example": false,
          "description": "Whether telemetry is enabled"
        },
        "EnforceEdgeID": {
          "type": "boolean",
          "example": false,
          "description": "EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone"
        },
        "FeatureFlagSettings": {
          "type": "object",
          "additionalProperties": {
            "type": "boolean"
          }
        },
        "GlobalDeploymentOptions": {
          "description": "Deployment options for encouraging git ops workflows",
          "$ref": "#/definitions/portainer.GlobalDeploymentOptions"
        },
        "HelmRepositoryURL": {
          "type": "string",
          "description": "Helm repository URL, defaults to \"\""
        },
        "InternalAuthSettings": {
          "$ref": "#/definitions/portainer.InternalAuthSettings"
        },
        "IsDockerDesktopExtension": {
          "type": "boolean"
        },
        "KubeconfigExpiry": {
          "type": "string",
          "example": "24h",
          "description": "The expiry of a Kubeconfig"
        },
        "KubectlShellImage": {
          "type": "string",
          "example": "portainer/kubectl-shell",
          "description": "KubectlImage, defaults to portainer/kubectl-shell"
        },
        "LDAPSettings": {
          "$ref": "#/definitions/portainer.LDAPSettings"
        },
        "LogoURL": {
          "type": "string",
          "example": "https://mycompany.mydomain.tld/logo.png",
          "description": "URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string"
        },
        "OAuthSettings": {
          "$ref": "#/definitions/portainer.OAuthSettings"
        },
        "SnapshotInterval": {
          "type": "string",
          "example": "5m",
          "description": "The interval in which environment(endpoint) snapshots are created"
        },
        "TemplatesURL": {
          "type": "string",
          "example": "https://raw.githubusercontent.com/portainer/templates/master/templates.json",
          "description": "URL to the templates that will be displayed in the UI when navigating to App Templates"
        },
        "TrustOnFirstConnect": {
          "type": "boolean",
          "example": false,
          "description": "TrustOnFirstConnect makes Portainer accepting edge agent connection by default"
        },
        "UserSessionTimeout": {
          "type": "string",
          "example": "5m",
          "description": "The duration of a user session"
        },
        "openAMTConfiguration": {
          "$ref": "#/definitions/portainer.OpenAMTConfiguration"
        }
      }
    },
    "portainer.Stack": {
      "type": "object",
      "properties": {
        "AdditionalFiles": {
          "type": "array",
          "description": "Only applies when deploying stack with multiple files",
          "items": {
            "type": "string"
          }
        },
        "AutoUpdate": {
          "description": "The GitOps update settings of a git stack",
          "$ref": "#/definitions/portainer.AutoUpdateSettings"
        },
        "EndpointId": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
        },
        "EntryPoint": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file"
        },
        "Env": {
          "type": "array",
          "description": "A list of environment(endpoint) variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Stack Identifier"
        },
        "Name": {
          "type": "string",
          "example": "myStack",
          "description": "Stack name"
        },
        "Option": {
          "description": "The stack deployment option",
          "$ref": "#/definitions/portainer.StackOption"
        },
        "ResourceControl": {
          "$ref": "#/definitions/portainer.ResourceControl"
        },
        "Status": {
          "type": "integer",
          "example": 1,
          "description": "Stack status (1 - active, 2 - inactive)"
        },
        "SwarmId": {
          "type": "string",
          "example": "jpofkc0i9uo9wtx1zesuk649w",
          "description": "Cluster identifier of the Swarm cluster where the stack is deployed"
        },
        "Type": {
          "type": "integer",
          "example": 2,
          "description": "Stack type. 1 for a Swarm stack, 2 for a Compose stack"
        },
        "createdBy": {
          "type": "string",
          "example": "admin",
          "description": "The username which created this stack"
        },
        "creationDate": {
          "type": "integer",
          "example": 1587399600,
          "description": "The date in unix time when stack was created"
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "gitConfig": {
          "description": "The git config of this stack",
          "$ref": "#/definitions/gittypes.RepoConfig"
        },
        "namespace": {
          "type": "string",
          "example": "default",
          "description": "Kubernetes namespace if stack is a kube application"
        },
        "projectPath": {
          "type": "string",
          "example": "/data/compose/myStack_jpofkc0i9uo9wtx1zesuk649w",
          "description": "Path on disk to the repository hosting the Stack file"
        },
        "updateDate": {
          "type": "integer",
          "example": 1587399600,
          "description": "The date in unix time when stack was last updated"
        },
        "updatedBy": {
          "type": "string",
          "example": "bob",
          "description": "The username which last updated this stack"
        }
      }
    },
    "portainer.StackDeploymentInfo": {
      "type": "object",
      "properties": {
        "ConfigHash": {
          "type": "string",
          "description": "ConfigHash is the commit hash of the git repository used for deploying the stack"
        },
        "FileVersion": {
          "type": "integer",
          "description": "FileVersion is the version of the stack file, used to detect changes"
        },
        "Version": {
          "type": "integer",
          "description": "Version is the version of the stack and also is the deployed version in edge agent"
        }
      }
    },
    "portainer.StackOption": {
      "type": "object",
      "properties": {
        "prune": {
          "type": "boolean",
          "example": false,
          "description": "Prune services that are no longer referenced"
        }
      }
    },
    "portainer.TLSConfiguration": {
      "type": "object",
      "properties": {
        "TLS": {
          "type": "boolean",
          "example": true,
          "description": "Use TLS"
        },
        "TLSCACert": {
          "type": "string",
          "example": "/data/tls/ca.pem",
          "description": "Path to the TLS CA certificate file"
        },
        "TLSCert": {
          "type": "string",
          "example": "/data/tls/cert.pem",
          "description": "Path to the TLS client certificate file"
        },
        "TLSKey": {
          "type": "string",
          "example": "/data/tls/key.pem",
          "description": "Path to the TLS client key file"
        },
        "TLSSkipVerify": {
          "type": "boolean",
          "example": false,
          "description": "Skip the verification of the server TLS certificate"
        }
      }
    },
    "portainer.Tag": {
      "type": "object",
      "properties": {
        "EndpointGroups": {
          "type": "object",
          "description": "A set of environment(endpoint) group ids that have this tag",
          "additionalProperties": {
            "type": "boolean"
          }
        },
        "Endpoints": {
          "type": "object",
          "description": "A set of environment(endpoint) ids that have this tag",
          "additionalProperties": {
            "type": "boolean"
          }
        },
        "Name": {
          "type": "string",
          "example": "org/acme",
          "description": "Tag name"
        },
        "id": {
          "type": "integer",
          "example": 1,
          "description": "Tag identifier"
        }
      }
    },
    "portainer.Team": {
      "type": "object",
      "properties": {
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Team Identifier"
        },
        "Name": {
          "type": "string",
          "example": "developers",
          "description": "Team name"
        }
      }
    },
    "portainer.TeamAccessPolicies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/portainer.AccessPolicy"
      }
    },
    "portainer.TeamMembership": {
      "type": "object",
      "properties": {
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Membership Identifier"
        },
        "Role": {
          "type": "integer",
          "example": 1,
          "description": "Team role (1 for team leader and 2 for team member)"
        },
        "TeamID": {
          "type": "integer",
          "example": 1,
          "description": "Team identifier"
        },
        "UserID": {
          "type": "integer",
          "example": 1,
          "description": "User identifier"
        }
      }
    },
    "portainer.TeamResourceAccess": {
      "type": "object",
      "properties": {
        "AccessLevel": {
          "type": "integer"
        },
        "TeamId": {
          "type": "integer"
        }
      }
    },
    "portainer.Template": {
      "type": "object",
      "properties": {
        "administrator_only": {
          "type": "boolean",
          "example": true,
          "description": "Whether the template should be available to administrators only"
        },
        "categories": {
          "type": "array",
          "example": [
            "database"
          ],
          "description": "A list of categories associated to the template",
          "items": {
            "type": "string"
          }
        },
        "command": {
          "type": "string",
          "example": "ls -lah",
          "description": "The command that will be executed in a container template"
        },
        "description": {
          "type": "string",
          "example": "High performance web server",
          "description": "Description of the template"
        },
        "env": {
          "type": "array",
          "description": "A list of environment(endpoint) variables used during the template deployment",
          "items": {
            "$ref": "#/definitions/portainer.TemplateEnv"
          }
        },
        "hostname": {
          "type": "string",
          "example": "mycontainer",
          "description": "Container hostname"
        },
        "id": {
          "type": "integer",
          "example": 1,
          "description": "Mandatory container/stack fields\nTemplate Identifier"
        },
        "image": {
          "type": "string",
          "example": "nginx:latest",
          "description": "Mandatory container fields\nImage associated to a container template. Mandatory for a container template"
        },
        "interactive": {
          "type": "boolean",
          "example": true,
          "description": "Whether the container should be started in\ninteractive mode (-i -t equivalent on the CLI)"
        },
        "labels": {
          "type": "array",
          "description": "Container labels",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "logo": {
          "type": "string",
          "example": "https://portainer.io/img/logo.svg",
          "description": "URL of the template's logo"
        },
        "name": {
          "type": "string",
          "example": "mystackname",
          "description": "Optional stack/container fields\nDefault name for the stack/container to be used on deployment"
        },
        "network": {
          "type": "string",
          "example": "mynet",
          "description": "Name of a network that will be used on container deployment if it exists inside the environment(endpoint)"
        },
        "note": {
          "type": "string",
          "example": "This is my <b>custom</b> template",
          "description": "A note that will be displayed in the UI. Supports HTML content"
        },
        "platform": {
          "type": "string",
          "example": "linux",
          "description": "Platform associated to the template.\nValid values are: 'linux', 'windows' or leave empty for multi-platform"
        },
        "ports": {
          "type": "array",
          "example": [
            "8080:80/tcp"
          ],
          "description": "A list of ports exposed by the container",
          "items": {
            "type": "string"
          }
        },
        "privileged": {
          "type": "boolean",
          "example": true,
          "description": "Whether the container should be started in privileged mode"
        },
        "registry": {
          "type": "string",
          "example": "quay.io",
          "description": "Optional container fields\nThe URL of a registry associated to the image for a container template"
        },
        "repository": {
          "description": "Mandatory stack fields",
          "$ref": "#/definitions/portainer.TemplateRepository"
        },
        "restart_policy": {
          "type": "string",
          "example": "on-failure",
          "description": "Container restart policy"
        },
        "stackFile": {
          "type": "string",
          "description": "Mandatory Edge stack fields\nStack file used for this template"
        },
        "title": {
          "type": "string",
          "example": "Nginx",
          "description": "Title of the template"
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Template type. Valid values are: 1 (container), 2 (Swarm stack), 3 (Compose stack), 4 (Compose edge stack)"
        },
        "volumes": {
          "type": "array",
          "description": "A list of volumes used during the container template deployment",
          "items": {
            "$ref": "#/definitions/portainer.TemplateVolume"
          }
        }
      }
    },
    "portainer.TemplateEnv": {
      "type": "object",
      "properties": {
        "default": {
          "type": "string",
          "example": "default_value",
          "description": "Default value that will be set for the variable"
        },
        "description": {
          "type": "string",
          "example": "MySQL root account password",
          "description": "Content of the tooltip that will be generated in the UI"
        },
        "label": {
          "type": "string",
          "example": "Root password",
          "description": "Text for the label that will be generated in the UI"
        },
        "name": {
          "type": "string",
          "example": "MYSQL_ROOT_PASSWORD",
          "description": "name of the environment(endpoint) variable"
        },
        "preset": {
          "type": "boolean",
          "example": false,
          "description": "If set to true, will not generate any input for this variable in the UI"
        },
        "select": {
          "type": "array",
          "description": "A list of name/value that will be used to generate a dropdown in the UI",
          "items": {
            "$ref": "#/definitions/portainer.TemplateEnvSelect"
          }
        }
      }
    },
    "portainer.TemplateEnvSelect": {
      "type": "object",
      "properties": {
        "default": {
          "type": "boolean",
          "example": false,
          "description": "Will set this choice as the default choice"
        },
        "text": {
          "type": "string",
          "example": "text value",
          "description": "Some text that will displayed as a choice"
        },
        "value": {
          "type": "string",
          "example": "value",
          "description": "A value that will be associated to the choice"
        }
      }
    },
    "portainer.TemplateRepository": {
      "type": "object",
      "properties": {
        "stackfile": {
          "type": "string",
          "example": "./subfolder/docker-compose.yml",
          "description": "Path to the stack file inside the git repository"
        },
        "url": {
          "type": "string",
          "example": "https://github.com/portainer/portainer-compose",
          "description": "URL of a git repository used to deploy a stack template. Mandatory for a Swarm/Compose stack template"
        }
      }
    },
    "portainer.TemplateVolume": {
      "type": "object",
      "properties": {
        "bind": {
          "type": "string",
          "example": "/tmp",
          "description": "Path on the host"
        },
        "container": {
          "type": "string",
          "example": "/data",
          "description": "Path inside the container"
        },
        "readonly": {
          "type": "boolean",
          "example": true,
          "description": "Whether the volume used should be readonly"
        }
      }
    },
    "portainer.User": {
      "type": "object",
      "properties": {
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "User Identifier"
        },
        "Role": {
          "type": "integer",
          "example": 1,
          "description": "User role (1 for administrator account and 2 for regular account)"
        },
        "ThemeSettings": {
          "$ref": "#/definitions/portainer.UserThemeSettings"
        },
        "TokenIssueAt": {
          "type": "integer",
          "example": 1
        },
        "UseCache": {
          "type": "boolean",
          "example": true
        },
        "UserTheme": {
          "type": "string",
          "example": "dark",
          "description": "Deprecated"
        },
        "Username": {
          "type": "string",
          "example": "bob"
        },
        "endpointAuthorizations": {
          "description": "Deprecated in DBVersion == 25",
          "$ref": "#/definitions/portainer.EndpointAuthorizations"
        },
        "portainerAuthorizations": {
          "description": "Deprecated in DBVersion == 25",
          "$ref": "#/definitions/portainer.Authorizations"
        }
      }
    },
    "portainer.UserAccessPolicies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/portainer.AccessPolicy"
      }
    },
    "portainer.UserResourceAccess": {
      "type": "object",
      "properties": {
        "AccessLevel": {
          "type": "integer"
        },
        "UserId": {
          "type": "integer",
          "description": "User identifier who created this template"
        }
      }
    },
    "portainer.UserThemeSettings": {
      "type": "object",
      "properties": {
        "color": {
          "type": "string",
          "example": "dark",
          "description": "Color represents the color theme of the UI",
          "enum": [
            "dark",
            "light",
            "highcontrast",
            "auto"
          ]
        }
      }
    },
    "portainer.Webhook": {
      "type": "object",
      "properties": {
        "EndpointId": {
          "type": "integer",
          "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
        },
        "Id": {
          "type": "integer",
          "example": 1,
          "description": "Webhook Identifier"
        },
        "RegistryId": {
          "type": "integer",
          "description": "Registry Identifier"
        },
        "ResourceId": {
          "type": "string"
        },
        "Token": {
          "type": "string"
        },
        "Type": {
          "type": "integer",
          "description": "Type of webhook (1 - service)"
        }
      }
    },
    "registries.registryConfigurePayload": {
      "type": "object",
      "required": [
        "authentication"
      ],
      "properties": {
        "authentication": {
          "type": "boolean",
          "example": false,
          "description": "Is authentication against this registry enabled"
        },
        "password": {
          "type": "string",
          "example": "registry_password",
          "description": "Password used to authenticate against this registry. required when Authentication is true"
        },
        "region": {
          "type": "string",
          "description": "ECR region"
        },
        "tls": {
          "type": "boolean",
          "example": true,
          "description": "Use TLS"
        },
        "tlscacertFile": {
          "type": "array",
          "description": "The TLS CA certificate file",
          "items": {
            "type": "integer"
          }
        },
        "tlscertFile": {
          "type": "array",
          "description": "The TLS client certificate file",
          "items": {
            "type": "integer"
          }
        },
        "tlskeyFile": {
          "type": "array",
          "description": "The TLS client key file",
          "items": {
            "type": "integer"
          }
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "Skip the verification of the server TLS certificate"
        },
        "username": {
          "type": "string",
          "example": "registry_user",
          "description": "Username used to authenticate against this registry. Required when Authentication is true"
        }
      }
    },
    "registries.registryCreatePayload": {
      "type": "object",
      "required": [
        "authentication",
        "name",
        "type",
        "url"
      ],
      "properties": {
        "authentication": {
          "type": "boolean",
          "example": false,
          "description": "Is authentication against this registry enabled"
        },
        "baseURL": {
          "type": "string",
          "example": "registry.mydomain.tld:2375",
          "description": "BaseURL required for ProGet registry"
        },
        "ecr": {
          "description": "ECR specific details, required when type = 7",
          "$ref": "#/definitions/portainer.EcrData"
        },
        "gitlab": {
          "description": "Gitlab specific details, required when type = 4",
          "$ref": "#/definitions/portainer.GitlabRegistryData"
        },
        "name": {
          "type": "string",
          "example": "my-registry",
          "description": "Name that will be used to identify this registry"
        },
        "password": {
          "type": "string",
          "example": "registry_password",
          "description": "Password used to authenticate against this registry. required when Authentication is true"
        },
        "quay": {
          "description": "Quay specific details, required when type = 1",
          "$ref": "#/definitions/portainer.QuayRegistryData"
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Registry Type. Valid values are:\n\t1 (Quay.io),\n\t2 (Azure container registry),\n\t3 (custom registry),\n\t4 (Gitlab registry),\n\t5 (ProGet registry),\n\t6 (DockerHub)\n\t7 (ECR)"
        },
        "url": {
          "type": "string",
          "example": "registry.mydomain.tld:2375/feed",
          "description": "URL or IP address of the Docker registry"
        },
        "username": {
          "type": "string",
          "example": "registry_user",
          "description": "Username used to authenticate against this registry. Required when Authentication is true"
        }
      }
    },
    "registries.registryUpdatePayload": {
      "type": "object",
      "required": [
        "authentication",
        "name",
        "url"
      ],
      "properties": {
        "authentication": {
          "type": "boolean",
          "example": false,
          "description": "Is authentication against this registry enabled"
        },
        "baseURL": {
          "type": "string",
          "example": "registry.mydomain.tld:2375",
          "description": "BaseURL is used for quay registry"
        },
        "ecr": {
          "description": "ECR data",
          "$ref": "#/definitions/portainer.EcrData"
        },
        "name": {
          "type": "string",
          "example": "my-registry",
          "description": "Name that will be used to identify this registry"
        },
        "password": {
          "type": "string",
          "example": "registry_password",
          "description": "Password used to authenticate against this registry. required when Authentication is true"
        },
        "quay": {
          "description": "Quay data",
          "$ref": "#/definitions/portainer.QuayRegistryData"
        },
        "registryAccesses": {
          "description": "Registry access control",
          "$ref": "#/definitions/portainer.RegistryAccesses"
        },
        "url": {
          "type": "string",
          "example": "registry.mydomain.tld:2375",
          "description": "URL or IP address of the Docker registry"
        },
        "username": {
          "type": "string",
          "example": "registry_user",
          "description": "Username used to authenticate against this registry. Required when Authentication is true"
        }
      }
    },
    "release.Chart": {
      "type": "object",
      "properties": {
        "files": {
          "type": "array",
          "description": "Files are miscellaneous files in a chart archive,\ne.g. README, LICENSE, etc.",
          "items": {
            "$ref": "#/definitions/release.File"
          }
        },
        "lock": {
          "description": "Lock is the contents of Chart.lock.",
          "$ref": "#/definitions/release.Lock"
        },
        "metadata": {
          "description": "Metadata is the contents of the Chartfile.",
          "$ref": "#/definitions/release.Metadata"
        },
        "schema": {
          "type": "array",
          "description": "Schema is an optional JSON schema for imposing structure on Values",
          "items": {
            "type": "integer"
          }
        },
        "templates": {
          "type": "array",
          "description": "Templates for this chart.",
          "items": {
            "$ref": "#/definitions/release.File"
          }
        },
        "values": {
          "type": "object",
          "description": "Values are default config for this chart.",
          "additionalProperties": {}
        }
      }
    },
    "release.Dependency": {
      "type": "object",
      "properties": {
        "alias": {
          "type": "string",
          "description": "Alias usable alias to be used for the chart"
        },
        "condition": {
          "type": "string",
          "description": "A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )"
        },
        "enabled": {
          "type": "boolean",
          "description": "Enabled bool determines if chart should be loaded"
        },
        "import-values": {
          "type": "array",
          "description": "ImportValues holds the mapping of source values to parent key to be imported. Each item can be a\nstring or pair of child/parent sublist items.",
          "items": {}
        },
        "name": {
          "type": "string",
          "description": "Name is the name of the dependency.\n\nThis must mach the name in the dependency's Chart.yaml."
        },
        "repository": {
          "type": "string",
          "description": "The URL to the repository.\n\nAppending `index.yaml` to this string should result in a URL that can be\nused to fetch the repository index."
        },
        "tags": {
          "type": "array",
          "description": "Tags can be used to group charts for enabling/disabling together",
          "items": {
            "type": "string"
          }
        },
        "version": {
          "type": "string",
          "description": "Version is the version (range) of this chart.\n\nA lock file will always produce a single version, while a dependency\nmay contain a semantic version range."
        }
      }
    },
    "release.File": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "description": "Data is the template as byte data.",
          "items": {
            "type": "integer"
          }
        },
        "name": {
          "type": "string",
          "description": "Name is the path-like name of the template."
        }
      }
    },
    "release.Hook": {
      "type": "object",
      "properties": {
        "delete_policies": {
          "type": "array",
          "description": "DeletePolicies are the policies that indicate when to delete the hook",
          "items": {
            "type": "string"
          }
        },
        "events": {
          "type": "array",
          "description": "Events are the events that this hook fires on.",
          "items": {
            "type": "string"
          }
        },
        "kind": {
          "type": "string",
          "description": "Kind is the Kubernetes kind."
        },
        "last_run": {
          "description": "LastRun indicates the date/time this was last run.",
          "$ref": "#/definitions/release.HookExecution"
        },
        "manifest": {
          "type": "string",
          "description": "Manifest is the manifest contents."
        },
        "name": {
          "type": "string"
        },
        "path": {
          "type": "string",
          "description": "Path is the chart-relative path to the template."
        },
        "weight": {
          "type": "integer",
          "description": "Weight indicates the sort order for execution among similar Hook type"
        }
      }
    },
    "release.HookExecution": {
      "type": "object",
      "properties": {
        "completed_at": {
          "type": "string",
          "description": "CompletedAt indicates the date/time this hook was completed."
        },
        "phase": {
          "type": "string",
          "description": "Phase indicates whether the hook completed successfully"
        },
        "started_at": {
          "type": "string",
          "description": "StartedAt indicates the date/time this hook was started"
        }
      }
    },
    "release.Lock": {
      "type": "object",
      "properties": {
        "dependencies": {
          "type": "array",
          "description": "Dependencies is the list of dependencies that this lock file has locked.",
          "items": {
            "$ref": "#/definitions/release.Dependency"
          }
        },
        "digest": {
          "type": "string",
          "description": "Digest is a hash of the dependencies in Chart.yaml."
        },
        "generated": {
          "type": "string",
          "description": "Generated is the date the lock file was last generated."
        }
      }
    },
    "release.Maintainer": {
      "type": "object",
      "properties": {
        "email": {
          "type": "string",
          "description": "Email is an optional email address to contact the named maintainer"
        },
        "name": {
          "type": "string",
          "description": "Name is a user name or organization name"
        },
        "url": {
          "type": "string",
          "description": "URL is an optional URL to an address for the named maintainer"
        }
      }
    },
    "release.Metadata": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations are additional mappings uninterpreted by Helm,\nmade available for inspection by other applications.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "The API Version of this chart. Required."
        },
        "appVersion": {
          "type": "string",
          "description": "The version of the application enclosed inside of this chart."
        },
        "condition": {
          "type": "string",
          "description": "The condition to check to enable chart"
        },
        "dependencies": {
          "type": "array",
          "description": "Dependencies are a list of dependencies for a chart.",
          "items": {
            "$ref": "#/definitions/release.Dependency"
          }
        },
        "deprecated": {
          "type": "boolean",
          "description": "Whether or not this chart is deprecated"
        },
        "description": {
          "type": "string",
          "description": "A one-sentence description of the chart"
        },
        "home": {
          "type": "string",
          "description": "The URL to a relevant project page, git repo, or contact person"
        },
        "icon": {
          "type": "string",
          "description": "The URL to an icon file."
        },
        "keywords": {
          "type": "array",
          "description": "A list of string keywords",
          "items": {
            "type": "string"
          }
        },
        "kubeVersion": {
          "type": "string",
          "description": "KubeVersion is a SemVer constraint specifying the version of Kubernetes required."
        },
        "maintainers": {
          "type": "array",
          "description": "A list of name and URL/email address combinations for the maintainer(s)",
          "items": {
            "$ref": "#/definitions/release.Maintainer"
          }
        },
        "name": {
          "type": "string",
          "description": "The name of the chart. Required."
        },
        "sources": {
          "type": "array",
          "description": "Source is the URL to the source code of this chart",
          "items": {
            "type": "string"
          }
        },
        "tags": {
          "type": "string",
          "description": "The tags to check to enable chart"
        },
        "type": {
          "type": "string",
          "description": "Specifies the chart type: application or library"
        },
        "version": {
          "type": "string",
          "description": "A SemVer 2 conformant version string of the chart. Required."
        }
      }
    },
    "release.Release": {
      "type": "object",
      "properties": {
        "chart": {
          "description": "Info provides information about a release\nInfo *Info `json:\"info,omitempty\"`\nChart is the chart that was released.",
          "$ref": "#/definitions/release.Chart"
        },
        "config": {
          "type": "object",
          "description": "Config is the set of extra Values added to the chart.\nThese values override the default values inside of the chart.",
          "additionalProperties": {}
        },
        "hooks": {
          "type": "array",
          "description": "Hooks are all of the hooks declared for this release.",
          "items": {
            "$ref": "#/definitions/release.Hook"
          }
        },
        "manifest": {
          "type": "string",
          "description": "Manifest is the string representation of the rendered template."
        },
        "name": {
          "type": "string",
          "description": "Name is the name of the release"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace is the kubernetes namespace of the release."
        },
        "version": {
          "type": "integer",
          "description": "Version is an int which represents the revision of the release."
        }
      }
    },
    "release.ReleaseElement": {
      "type": "object",
      "properties": {
        "app_version": {
          "type": "string"
        },
        "chart": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "revision": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "updated": {
          "type": "string"
        }
      }
    },
    "resource.Quantity": {
      "type": "object",
      "properties": {
        "Format": {
          "type": "string"
        }
      }
    },
    "resourcecontrols.resourceControlCreatePayload": {
      "type": "object",
      "required": [
        "resourceID",
        "type"
      ],
      "properties": {
        "administratorsOnly": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to resource only to admins"
        },
        "public": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to the associated resource to any user"
        },
        "resourceID": {
          "type": "string",
          "example": "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
        },
        "subResourceIDs": {
          "type": "array",
          "example": [
            "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
          ],
          "description": "List of Docker resources that will inherit this access control",
          "items": {
            "type": "string"
          }
        },
        "teams": {
          "type": "array",
          "example": [
            56,
            7
          ],
          "description": "List of team identifiers with access to the associated resource",
          "items": {
            "type": "integer"
          }
        },
        "type": {
          "type": "integer",
          "example": 1,
          "description": "Type of Resource. Valid values are: 1 - container, 2 - service\n3 - volume, 4 - network, 5 - secret, 6 - stack, 7 - config, 8 - custom template, 9 - azure-container-group"
        },
        "users": {
          "type": "array",
          "example": [
            1,
            4
          ],
          "description": "List of user identifiers with access to the associated resource",
          "items": {
            "type": "integer"
          }
        }
      }
    },
    "resourcecontrols.resourceControlUpdatePayload": {
      "type": "object",
      "properties": {
        "administratorsOnly": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to resource only to admins"
        },
        "public": {
          "type": "boolean",
          "example": true,
          "description": "Permit access to the associated resource to any user"
        },
        "teams": {
          "type": "array",
          "example": [
            7
          ],
          "description": "List of team identifiers with access to the associated resource",
          "items": {
            "type": "integer"
          }
        },
        "users": {
          "type": "array",
          "example": [
            4
          ],
          "description": "List of user identifiers with access to the associated resource",
          "items": {
            "type": "integer"
          }
        }
      }
    },
    "settings.publicSettingsResponse": {
      "type": "object",
      "properties": {
        "AuthenticationMethod": {
          "type": "integer",
          "example": 1,
          "description": "Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth"
        },
        "EnableEdgeComputeFeatures": {
          "type": "boolean",
          "example": true,
          "description": "Whether edge compute features are enabled"
        },
        "EnableTelemetry": {
          "type": "boolean",
          "example": true,
          "description": "Whether telemetry is enabled"
        },
        "Features": {
          "type": "object",
          "description": "Supported feature flags",
          "additionalProperties": {
            "type": "boolean"
          }
        },
        "GlobalDeploymentOptions": {
          "description": "Deployment options for encouraging deployment as code",
          "$ref": "#/definitions/portainer.GlobalDeploymentOptions"
        },
        "IsDockerDesktopExtension": {
          "type": "boolean",
          "example": false
        },
        "LogoURL": {
          "type": "string",
          "example": "https://mycompany.mydomain.tld/logo.png",
          "description": "URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string"
        },
        "OAuthLoginURI": {
          "type": "string",
          "example": "https://gitlab.com/oauth",
          "description": "The URL used for oauth login"
        },
        "OAuthLogoutURI": {
          "type": "string",
          "example": "https://gitlab.com/oauth/logout",
          "description": "The URL used for oauth logout"
        },
        "RequiredPasswordLength": {
          "type": "integer",
          "example": 1,
          "description": "The minimum required length for a password of any user when using internal auth mode"
        },
        "TeamSync": {
          "type": "boolean",
          "example": true,
          "description": "Whether team sync is enabled"
        },
        "edge": {
          "$ref": "settings.publicSettingsResponse_edge"
        },
        "isAMTEnabled": {
          "type": "boolean",
          "description": "Whether AMT is enabled"
        },
        "kubeconfigExpiry": {
          "type": "string",
          "example": "24h",
          "description": "The expiry of a Kubeconfig",
          "default": "0"
        }
      }
    },
    "settings.settingsUpdatePayload": {
      "type": "object",
      "properties": {
        "EdgePortainerURL": {
          "type": "string",
          "description": "EdgePortainerURL is the URL that is exposed to edge agents"
        },
        "authenticationMethod": {
          "type": "integer",
          "example": 1,
          "description": "Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth"
        },
        "blackListedLabels": {
          "type": "array",
          "description": "A list of label name & value that will be used to hide containers when querying containers",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "edgeAgentCheckinInterval": {
          "type": "integer",
          "example": 5
        },
        "enableEdgeComputeFeatures": {
          "type": "boolean",
          "example": true,
          "description": "Whether edge compute features are enabled"
        },
        "enableTelemetry": {
          "type": "boolean",
          "example": false,
          "description": "Whether telemetry is enabled"
        },
        "enforceEdgeID": {
          "type": "boolean",
          "example": false,
          "description": "EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone"
        },
        "globalDeploymentOptions": {
          "description": "Deployment options for encouraging deployment as code",
          "$ref": "#/definitions/portainer.GlobalDeploymentOptions"
        },
        "helmRepositoryURL": {
          "type": "string",
          "example": "https://kubernetes.github.io/ingress-nginx",
          "description": "Helm repository URL"
        },
        "internalAuthSettings": {
          "$ref": "#/definitions/portainer.InternalAuthSettings"
        },
        "kubeconfigExpiry": {
          "type": "string",
          "example": "24h",
          "description": "The expiry of a Kubeconfig",
          "default": "0"
        },
        "kubectlShellImage": {
          "type": "string",
          "example": "portainer/kubectl-shell:latest",
          "description": "Kubectl Shell Image"
        },
        "ldapsettings": {
          "$ref": "#/definitions/portainer.LDAPSettings"
        },
        "logoURL": {
          "type": "string",
          "example": "https://mycompany.mydomain.tld/logo.png",
          "description": "URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string"
        },
        "oauthSettings": {
          "$ref": "#/definitions/portainer.OAuthSettings"
        },
        "snapshotInterval": {
          "type": "string",
          "example": "5m",
          "description": "The interval in which environment(endpoint) snapshots are created"
        },
        "templatesURL": {
          "type": "string",
          "example": "https://raw.githubusercontent.com/portainer/templates/master/templates.json",
          "description": "URL to the templates that will be displayed in the UI when navigating to App Templates"
        },
        "trustOnFirstConnect": {
          "type": "boolean",
          "example": false,
          "description": "TrustOnFirstConnect makes Portainer accepting edge agent connection by default"
        },
        "userSessionTimeout": {
          "type": "string",
          "example": "5m",
          "description": "The duration of a user session"
        }
      }
    },
    "ssl.sslUpdatePayload": {
      "type": "object",
      "properties": {
        "cert": {
          "type": "string",
          "description": "SSL Certificates"
        },
        "httpenabled": {
          "type": "boolean"
        },
        "key": {
          "type": "string"
        }
      }
    },
    "stacks.composeStackFromFileContentPayload": {
      "type": "object",
      "required": [
        "name",
        "stackFileContent"
      ],
      "properties": {
        "env": {
          "type": "array",
          "description": "A list of environment variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "name": {
          "type": "string",
          "example": "myStack",
          "description": "Name of the stack"
        },
        "stackFileContent": {
          "type": "string",
          "example": "version: 3\n services:\n web:\n image:nginx",
          "description": "Content of the Stack file"
        }
      }
    },
    "stacks.composeStackFromGitRepositoryPayload": {
      "type": "object",
      "required": [
        "name",
        "repositoryURL"
      ],
      "properties": {
        "additionalFiles": {
          "type": "array",
          "example": [
            "[nz.compose.yml",
            " uat.compose.yml]"
          ],
          "description": "Applicable when deploying with multiple stack files",
          "items": {
            "type": "string"
          }
        },
        "autoUpdate": {
          "description": "Optional GitOps update configuration",
          "$ref": "#/definitions/portainer.AutoUpdateSettings"
        },
        "composeFile": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file inside the Git repository",
          "default": "docker-compose.yml"
        },
        "env": {
          "type": "array",
          "description": "A list of environment variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "name": {
          "type": "string",
          "example": "myStack",
          "description": "Name of the stack"
        },
        "repositoryAuthentication": {
          "type": "boolean",
          "example": true,
          "description": "Use basic authentication to clone the Git repository"
        },
        "repositoryPassword": {
          "type": "string",
          "example": "myGitPassword",
          "description": "Password used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "repositoryReferenceName": {
          "type": "string",
          "example": "refs/heads/master",
          "description": "Reference name of a Git repository hosting the Stack file"
        },
        "repositoryURL": {
          "type": "string",
          "example": "https://github.com/openfaas/faas",
          "description": "URL of a Git repository hosting the Stack file"
        },
        "repositoryUsername": {
          "type": "string",
          "example": "myGitUsername",
          "description": "Username used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        }
      }
    },
    "stacks.kubernetesGitDeploymentPayload": {
      "type": "object",
      "properties": {
        "additionalFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "autoUpdate": {
          "$ref": "#/definitions/portainer.AutoUpdateSettings"
        },
        "composeFormat": {
          "type": "boolean"
        },
        "manifestFile": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "repositoryAuthentication": {
          "type": "boolean"
        },
        "repositoryPassword": {
          "type": "string"
        },
        "repositoryReferenceName": {
          "type": "string"
        },
        "repositoryURL": {
          "type": "string"
        },
        "repositoryUsername": {
          "type": "string"
        },
        "stackName": {
          "type": "string"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        }
      }
    },
    "stacks.kubernetesManifestURLDeploymentPayload": {
      "type": "object",
      "properties": {
        "composeFormat": {
          "type": "boolean"
        },
        "manifestURL": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "stackName": {
          "type": "string"
        }
      }
    },
    "stacks.kubernetesStringDeploymentPayload": {
      "type": "object",
      "properties": {
        "composeFormat": {
          "type": "boolean"
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "namespace": {
          "type": "string"
        },
        "stackFileContent": {
          "type": "string"
        },
        "stackName": {
          "type": "string"
        }
      }
    },
    "stacks.stackFileResponse": {
      "type": "object",
      "properties": {
        "StackFileContent": {
          "type": "string",
          "example": "version: 3\n services:\n web:\n image:nginx",
          "description": "Content of the Stack file"
        }
      }
    },
    "stacks.stackGitRedployPayload": {
      "type": "object",
      "properties": {
        "env": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "prune": {
          "type": "boolean"
        },
        "pullImage": {
          "type": "boolean",
          "example": false,
          "description": "Force a pulling to current image with the original tag though the image is already the latest"
        },
        "repositoryAuthentication": {
          "type": "boolean"
        },
        "repositoryPassword": {
          "type": "string"
        },
        "repositoryReferenceName": {
          "type": "string"
        },
        "repositoryUsername": {
          "type": "string"
        },
        "stackName": {
          "type": "string"
        }
      }
    },
    "stacks.stackGitUpdatePayload": {
      "type": "object",
      "properties": {
        "autoUpdate": {
          "$ref": "#/definitions/portainer.AutoUpdateSettings"
        },
        "env": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "prune": {
          "type": "boolean"
        },
        "repositoryAuthentication": {
          "type": "boolean"
        },
        "repositoryPassword": {
          "type": "string"
        },
        "repositoryReferenceName": {
          "type": "string"
        },
        "repositoryUsername": {
          "type": "string"
        },
        "tlsskipVerify": {
          "type": "boolean"
        }
      }
    },
    "stacks.stackMigratePayload": {
      "type": "object",
      "required": [
        "endpointID"
      ],
      "properties": {
        "endpointID": {
          "type": "integer",
          "example": 2,
          "description": "Environment(Endpoint) identifier of the target environment(endpoint) where the stack will be relocated"
        },
        "name": {
          "type": "string",
          "example": "new-stack",
          "description": "If provided will rename the migrated stack"
        },
        "swarmID": {
          "type": "string",
          "example": "jpofkc0i9uo9wtx1zesuk649w",
          "description": "Swarm cluster identifier, must match the identifier of the cluster where the stack will be relocated"
        }
      }
    },
    "stacks.swarmStackFromFileContentPayload": {
      "type": "object",
      "required": [
        "name",
        "stackFileContent",
        "swarmID"
      ],
      "properties": {
        "env": {
          "type": "array",
          "description": "A list of environment variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "name": {
          "type": "string",
          "example": "myStack",
          "description": "Name of the stack"
        },
        "stackFileContent": {
          "type": "string",
          "example": "version: 3\n services:\n web:\n image:nginx",
          "description": "Content of the Stack file"
        },
        "swarmID": {
          "type": "string",
          "example": "jpofkc0i9uo9wtx1zesuk649w",
          "description": "Swarm cluster identifier"
        }
      }
    },
    "stacks.swarmStackFromGitRepositoryPayload": {
      "type": "object",
      "required": [
        "name",
        "repositoryURL",
        "swarmID"
      ],
      "properties": {
        "additionalFiles": {
          "type": "array",
          "example": [
            "[nz.compose.yml",
            " uat.compose.yml]"
          ],
          "description": "Applicable when deploying with multiple stack files",
          "items": {
            "type": "string"
          }
        },
        "autoUpdate": {
          "description": "Optional GitOps update configuration",
          "$ref": "#/definitions/portainer.AutoUpdateSettings"
        },
        "composeFile": {
          "type": "string",
          "example": "docker-compose.yml",
          "description": "Path to the Stack file inside the Git repository",
          "default": "docker-compose.yml"
        },
        "env": {
          "type": "array",
          "description": "A list of environment variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "fromAppTemplate": {
          "type": "boolean",
          "example": false,
          "description": "Whether the stack is from a app template"
        },
        "name": {
          "type": "string",
          "example": "myStack",
          "description": "Name of the stack"
        },
        "repositoryAuthentication": {
          "type": "boolean",
          "example": true,
          "description": "Use basic authentication to clone the Git repository"
        },
        "repositoryPassword": {
          "type": "string",
          "example": "myGitPassword",
          "description": "Password used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "repositoryReferenceName": {
          "type": "string",
          "example": "refs/heads/master",
          "description": "Reference name of a Git repository hosting the Stack file"
        },
        "repositoryURL": {
          "type": "string",
          "example": "https://github.com/openfaas/faas",
          "description": "URL of a Git repository hosting the Stack file"
        },
        "repositoryUsername": {
          "type": "string",
          "example": "myGitUsername",
          "description": "Username used in basic authentication. Required when RepositoryAuthentication is true."
        },
        "swarmID": {
          "type": "string",
          "example": "jpofkc0i9uo9wtx1zesuk649w",
          "description": "Swarm cluster identifier"
        },
        "tlsskipVerify": {
          "type": "boolean",
          "example": false,
          "description": "TLSSkipVerify skips SSL verification when cloning the Git repository"
        }
      }
    },
    "stacks.updateSwarmStackPayload": {
      "type": "object",
      "properties": {
        "env": {
          "type": "array",
          "description": "A list of environment(endpoint) variables used during stack deployment",
          "items": {
            "$ref": "#/definitions/portainer.Pair"
          }
        },
        "prune": {
          "type": "boolean",
          "example": true,
          "description": "Prune services that are no longer referenced (only available for Swarm stacks)"
        },
        "pullImage": {
          "type": "boolean",
          "example": false,
          "description": "Force a pulling to current image with the original tag though the image is already the latest"
        },
        "stackFileContent": {
          "type": "string",
          "example": "version: 3\n services:\n web:\n image:nginx",
          "description": "New content of the Stack file"
        }
      }
    },
    "swarm.ServiceUpdateResponse": {
      "type": "object",
      "properties": {
        "Warnings": {
          "type": "array",
          "description": "Optional warning messages",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "system.nodesCountResponse": {
      "type": "object",
      "properties": {
        "nodes": {
          "type": "integer"
        }
      }
    },
    "system.status": {
      "type": "object",
      "properties": {
        "Version": {
          "type": "string",
          "example": "2.0.0",
          "description": "Portainer API version"
        },
        "instanceID": {
          "type": "string",
          "example": "299ab403-70a8-4c05-92f7-bf7a994d50df",
          "description": "Server Instance ID"
        }
      }
    },
    "system.systemInfoResponse": {
      "type": "object",
      "properties": {
        "agents": {
          "type": "integer"
        },
        "edgeAgents": {
          "type": "integer"
        },
        "platform": {
          "type": "string"
        }
      }
    },
    "system.versionResponse": {
      "type": "object",
      "properties": {
        "LatestVersion": {
          "type": "string",
          "example": "2.0.0",
          "description": "The latest version available"
        },
        "ServerEdition": {
          "type": "string",
          "example": "CE/EE"
        },
        "UpdateAvailable": {
          "type": "boolean",
          "example": false,
          "description": "Whether portainer has an update available"
        },
        "VersionSupport": {
          "type": "string",
          "example": "STS/LTS"
        },
        "build": {
          "$ref": "#/definitions/build.BuildInfo"
        },
        "databaseVersion": {
          "type": "string"
        },
        "dependencies": {
          "$ref": "#/definitions/build.DependenciesInfo"
        },
        "runtime": {
          "$ref": "#/definitions/build.RuntimeInfo"
        },
        "serverVersion": {
          "type": "string"
        }
      }
    },
    "tags.tagCreatePayload": {
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "type": "string",
          "example": "org/acme"
        }
      }
    },
    "teammemberships.teamMembershipCreatePayload": {
      "type": "object",
      "required": [
        "role",
        "teamID",
        "userID"
      ],
      "properties": {
        "role": {
          "type": "integer",
          "example": 1,
          "description": "Role for the user inside the team (1 for leader and 2 for regular member)"
        },
        "teamID": {
          "type": "integer",
          "example": 1,
          "description": "Team identifier"
        },
        "userID": {
          "type": "integer",
          "example": 1,
          "description": "User identifier"
        }
      }
    },
    "teammemberships.teamMembershipUpdatePayload": {
      "type": "object",
      "required": [
        "role",
        "teamID",
        "userID"
      ],
      "properties": {
        "role": {
          "type": "integer",
          "example": 1,
          "description": "Role for the user inside the team (1 for leader and 2 for regular member)"
        },
        "teamID": {
          "type": "integer",
          "example": 1,
          "description": "Team identifier"
        },
        "userID": {
          "type": "integer",
          "example": 1,
          "description": "User identifier"
        }
      }
    },
    "teams.teamCreatePayload": {
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "type": "string",
          "example": "developers",
          "description": "Name"
        },
        "teamLeaders": {
          "type": "array",
          "example": [
            3,
            5
          ],
          "description": "TeamLeaders",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "User identifier"
          }
        }
      }
    },
    "teams.teamUpdatePayload": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "example": "developers",
          "description": "Name"
        }
      }
    },
    "templates.fileResponse": {
      "type": "object",
      "properties": {
        "fileContent": {
          "type": "string",
          "example": "version:2",
          "description": "The requested file content"
        }
      }
    },
    "templates.listResponse": {
      "type": "object",
      "properties": {
        "templates": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.Template"
          }
        },
        "version": {
          "type": "string"
        }
      }
    },
    "users.accessTokenResponse": {
      "type": "object",
      "properties": {
        "apiKey": {
          "$ref": "#/definitions/portainer.APIKey"
        },
        "rawAPIKey": {
          "type": "string"
        }
      }
    },
    "users.addHelmRepoUrlPayload": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string"
        }
      }
    },
    "users.adminInitPayload": {
      "type": "object",
      "required": [
        "password",
        "username"
      ],
      "properties": {
        "password": {
          "type": "string",
          "example": "admin-password",
          "description": "Password for the admin user"
        },
        "username": {
          "type": "string",
          "example": "admin",
          "description": "Username for the admin user"
        }
      }
    },
    "users.helmUserRepositoryResponse": {
      "type": "object",
      "properties": {
        "GlobalRepository": {
          "type": "string"
        },
        "UserRepositories": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/portainer.HelmUserRepository"
          }
        }
      }
    },
    "users.themePayload": {
      "type": "object",
      "properties": {
        "color": {
          "type": "string",
          "example": "dark",
          "description": "Color represents the color theme of the UI",
          "enum": [
            "dark",
            "light",
            "highcontrast",
            "auto"
          ]
        }
      }
    },
    "users.userAccessTokenCreatePayload": {
      "type": "object",
      "required": [
        "description",
        "password"
      ],
      "properties": {
        "description": {
          "type": "string",
          "example": "github-api-key"
        },
        "password": {
          "type": "string",
          "example": "password"
        }
      }
    },
    "users.userCreatePayload": {
      "type": "object",
      "required": [
        "password",
        "role",
        "username"
      ],
      "properties": {
        "password": {
          "type": "string",
          "example": "cg9Wgky3"
        },
        "role": {
          "type": "integer",
          "example": 2,
          "description": "User role (1 for administrator account and 2 for regular account)"
        },
        "username": {
          "type": "string",
          "example": "bob"
        }
      }
    },
    "users.userUpdatePasswordPayload": {
      "type": "object",
      "required": [
        "newPassword",
        "password"
      ],
      "properties": {
        "newPassword": {
          "type": "string",
          "example": "new_passwd",
          "description": "New Password"
        },
        "password": {
          "type": "string",
          "example": "passwd",
          "description": "Current Password"
        }
      }
    },
    "users.userUpdatePayload": {
      "type": "object",
      "required": [
        "newPassword",
        "password",
        "role",
        "useCache",
        "username"
      ],
      "properties": {
        "newPassword": {
          "type": "string",
          "example": "asfj2emv"
        },
        "password": {
          "type": "string",
          "example": "cg9Wgky3"
        },
        "role": {
          "type": "integer",
          "example": 2,
          "description": "User role (1 for administrator account and 2 for regular account)"
        },
        "theme": {
          "$ref": "#/definitions/users.themePayload"
        },
        "useCache": {
          "type": "boolean",
          "example": true
        },
        "username": {
          "type": "string",
          "example": "bob"
        }
      }
    },
    "v1.CSIPersistentVolumeSource": {
      "type": "object",
      "properties": {
        "controllerExpandSecretRef": {
          "description": "controllerExpandSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nControllerExpandVolume call.\nThis field is optional, and may be empty if no secret is required. If the\nsecret object contains more than one secret, all secrets are passed.\n+optional",
          "$ref": "#/definitions/v1.SecretReference"
        },
        "controllerPublishSecretRef": {
          "description": "controllerPublishSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nControllerPublishVolume and ControllerUnpublishVolume calls.\nThis field is optional, and may be empty if no secret is required. If the\nsecret object contains more than one secret, all secrets are passed.\n+optional",
          "$ref": "#/definitions/v1.SecretReference"
        },
        "driver": {
          "type": "string",
          "description": "driver is the name of the driver to use for this volume.\nRequired."
        },
        "fsType": {
          "type": "string",
          "description": "fsType to mount. Must be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\".\n+optional"
        },
        "nodeExpandSecretRef": {
          "description": "nodeExpandSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nNodeExpandVolume call.\nThis field is optional, may be omitted if no secret is required. If the\nsecret object contains more than one secret, all secrets are passed.\n+optional",
          "$ref": "#/definitions/v1.SecretReference"
        },
        "nodePublishSecretRef": {
          "description": "nodePublishSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nNodePublishVolume and NodeUnpublishVolume calls.\nThis field is optional, and may be empty if no secret is required. If the\nsecret object contains more than one secret, all secrets are passed.\n+optional",
          "$ref": "#/definitions/v1.SecretReference"
        },
        "nodeStageSecretRef": {
          "description": "nodeStageSecretRef is a reference to the secret object containing sensitive\ninformation to pass to the CSI driver to complete the CSI NodeStageVolume\nand NodeStageVolume and NodeUnstageVolume calls.\nThis field is optional, and may be empty if no secret is required. If the\nsecret object contains more than one secret, all secrets are passed.\n+optional",
          "$ref": "#/definitions/v1.SecretReference"
        },
        "readOnly": {
          "type": "boolean",
          "description": "readOnly value to pass to ControllerPublishVolumeRequest.\nDefaults to false (read/write).\n+optional"
        },
        "volumeAttributes": {
          "type": "object",
          "description": "volumeAttributes of the volume to publish.\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "volumeHandle": {
          "type": "string",
          "description": "volumeHandle is the unique volume name returned by the CSI volume\nplugin’s CreateVolume to refer to the volume on all subsequent calls.\nRequired."
        }
      }
    },
    "v1.Capabilities": {
      "type": "object",
      "properties": {
        "add": {
          "type": "array",
          "description": "Added capabilities\n+optional",
          "items": {
            "type": "string"
          }
        },
        "drop": {
          "type": "array",
          "description": "Removed capabilities\n+optional",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "v1.ClientIPConfig": {
      "type": "object",
      "properties": {
        "timeoutSeconds": {
          "type": "integer",
          "description": "timeoutSeconds specifies the seconds of ClientIP type session sticky time.\nThe value must be >0 && <=86400(for 1 day) if ServiceAffinity == \"ClientIP\".\nDefault value is 10800(for 3 hours).\n+optional"
        }
      }
    },
    "v1.Condition": {
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "type": "string",
          "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.\n+required\n+kubebuilder:validation:Required\n+kubebuilder:validation:Type=string\n+kubebuilder:validation:Format=date-time"
        },
        "message": {
          "type": "string",
          "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.\n+required\n+kubebuilder:validation:Required\n+kubebuilder:validation:MaxLength=32768"
        },
        "observedGeneration": {
          "type": "integer",
          "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.\n+optional\n+kubebuilder:validation:Minimum=0"
        },
        "reason": {
          "type": "string",
          "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.\n+required\n+kubebuilder:validation:Required\n+kubebuilder:validation:MaxLength=1024\n+kubebuilder:validation:MinLength=1\n+kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`"
        },
        "status": {
          "type": "string",
          "description": "status of the condition, one of True, False, Unknown.\n+required\n+kubebuilder:validation:Required\n+kubebuilder:validation:Enum=True;False;Unknown"
        },
        "type": {
          "type": "string",
          "description": "type of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n+required\n+kubebuilder:validation:Required\n+kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`\n+kubebuilder:validation:MaxLength=316"
        }
      }
    },
    "v1.ConfigMapEnvSource": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO: Add other useful fields. apiVersion, kind, uid?\n+optional"
        },
        "optional": {
          "type": "boolean",
          "description": "Specify whether the ConfigMap must be defined\n+optional"
        }
      }
    },
    "v1.ConfigMapKeySelector": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key to select."
        },
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO: Add other useful fields. apiVersion, kind, uid?\n+optional"
        },
        "optional": {
          "type": "boolean",
          "description": "Specify whether the ConfigMap or its key must be defined\n+optional"
        }
      }
    },
    "v1.Container": {
      "type": "object",
      "properties": {
        "args": {
          "type": "array",
          "description": "Arguments to the entrypoint.\nThe container image's CMD is used if this is not provided.\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable\ncannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will\nproduce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless\nof whether the variable exists or not. Cannot be updated.\nMore info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell\n+optional",
          "items": {
            "type": "string"
          }
        },
        "command": {
          "type": "array",
          "description": "Entrypoint array. Not executed within a shell.\nThe container image's ENTRYPOINT is used if this is not provided.\nVariable references $(VAR_NAME) are expanded using the container's environment. If a variable\ncannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will\nproduce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless\nof whether the variable exists or not. Cannot be updated.\nMore info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell\n+optional",
          "items": {
            "type": "string"
          }
        },
        "env": {
          "type": "array",
          "description": "List of environment variables to set in the container.\nCannot be updated.\n+optional\n+patchMergeKey=name\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.EnvVar"
          }
        },
        "envFrom": {
          "type": "array",
          "description": "List of sources to populate environment variables in the container.\nThe keys defined within a source must be a C_IDENTIFIER. All invalid keys\nwill be reported as an event when the container is starting. When a key exists in multiple\nsources, the value associated with the last source will take precedence.\nValues defined by an Env with a duplicate key will take precedence.\nCannot be updated.\n+optional",
          "items": {
            "$ref": "#/definitions/v1.EnvFromSource"
          }
        },
        "image": {
          "type": "string",
          "description": "Container image name.\nMore info: https://kubernetes.io/docs/concepts/containers/images\nThis field is optional to allow higher level config management to default or override\ncontainer images in workload controllers like Deployments and StatefulSets.\n+optional"
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "Image pull policy.\nOne of Always, Never, IfNotPresent.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/containers/images#updating-images\n+optional"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events.\nCannot be updated.\n+optional",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness.\nContainer will be restarted if the probe fails.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\n+optional",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "type": "string",
          "description": "Name of the container specified as a DNS_LABEL.\nEach container in a pod must have a unique name (DNS_LABEL).\nCannot be updated."
        },
        "ports": {
          "type": "array",
          "description": "List of ports to expose from the container. Not specifying a port here\nDOES NOT prevent that port from being exposed. Any port which is\nlistening on the default \"0.0.0.0\" address inside a container will be\naccessible from the network.\nModifying this array with strategic merge patch may corrupt the data.\nFor more information See https://github.com/kubernetes/kubernetes/issues/108255.\nCannot be updated.\n+optional\n+patchMergeKey=containerPort\n+patchStrategy=merge\n+listType=map\n+listMapKey=containerPort\n+listMapKey=protocol",
          "items": {
            "$ref": "#/definitions/v1.ContainerPort"
          }
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness.\nContainer will be removed from service endpoints if the probe fails.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\n+optional",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "type": "array",
          "description": "Resources resize policy for the container.\n+featureGate=InPlacePodVerticalScaling\n+optional\n+listType=atomic",
          "items": {
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          }
        },
        "resources": {
          "description": "Compute Resources required by this container.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional",
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "type": "string",
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod.\nThis field may only be set for init containers, and the only allowed value is \"Always\".\nFor non-init containers or when this field is not specified,\nthe restart behavior is defined by the Pod's restart policy and the container type.\nSetting the RestartPolicy as \"Always\" for the init container will have the following effect:\nthis init container will be continually restarted on\nexit until all regular containers have terminated. Once all regular\ncontainers have completed, all init containers with restartPolicy \"Always\"\nwill be shut down. This lifecycle differs from normal init containers and\nis often referred to as a \"sidecar\" container. Although this init\ncontainer still starts in the init container sequence, it does not wait\nfor the container to complete before proceeding to the next init\ncontainer. Instead, the next init container starts immediately after this\ninit container is started, or after any startupProbe has successfully\ncompleted.\n+featureGate=SidecarContainers\n+optional"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with.\nIf set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.\nMore info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n+optional",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized.\nIf specified, no other probes are executed until this completes successfully.\nIf this probe fails, the Pod will be restarted, just as if the livenessProbe failed.\nThis can be used to provide different probe parameters at the beginning of a Pod's lifecycle,\nwhen it might take a long time to load data or warm a cache, than during steady-state operation.\nThis cannot be updated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\n+optional",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "type": "boolean",
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this\nis not set, reads from stdin in the container will always result in EOF.\nDefault is false.\n+optional"
        },
        "stdinOnce": {
          "type": "boolean",
          "description": "Whether the container runtime should close the stdin channel after it has been opened by\na single attach. When stdin is true the stdin stream will remain open across multiple attach\nsessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the\nfirst client attaches to stdin, and then remains open and accepts data until the client disconnects,\nat which time stdin is closed and remains closed until the container is restarted. If this\nflag is false, a container processes that reads from stdin will never receive an EOF.\nDefault is false\n+optional"
        },
        "terminationMessagePath": {
          "type": "string",
          "description": "Optional: Path at which the file to which the container's termination message\nwill be written is mounted into the container's filesystem.\nMessage written is intended to be brief final status, such as an assertion failure message.\nWill be truncated by the node if greater than 4096 bytes. The total message length across\nall containers will be limited to 12kb.\nDefaults to /dev/termination-log.\nCannot be updated.\n+optional"
        },
        "terminationMessagePolicy": {
          "type": "string",
          "description": "Indicate how the termination message should be populated. File will use the contents of\nterminationMessagePath to populate the container status message on both success and failure.\nFallbackToLogsOnError will use the last chunk of container log output if the termination\nmessage file is empty and the container exited with an error.\nThe log output is limited to 2048 bytes or 80 lines, whichever is smaller.\nDefaults to File.\nCannot be updated.\n+optional"
        },
        "tty": {
          "type": "boolean",
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.\nDefault is false.\n+optional"
        },
        "volumeDevices": {
          "type": "array",
          "description": "volumeDevices is the list of block devices to be used by the container.\n+patchMergeKey=devicePath\n+patchStrategy=merge\n+optional",
          "items": {
            "$ref": "#/definitions/v1.VolumeDevice"
          }
        },
        "volumeMounts": {
          "type": "array",
          "description": "Pod volumes to mount into the container's filesystem.\nCannot be updated.\n+optional\n+patchMergeKey=mountPath\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.VolumeMount"
          }
        },
        "workingDir": {
          "type": "string",
          "description": "Container's working directory.\nIf not specified, the container runtime's default will be used, which\nmight be configured in the container image.\nCannot be updated.\n+optional"
        }
      }
    },
    "v1.ContainerPort": {
      "type": "object",
      "properties": {
        "containerPort": {
          "type": "integer",
          "description": "Number of port to expose on the pod's IP address.\nThis must be a valid port number, 0 < x < 65536."
        },
        "hostIP": {
          "type": "string",
          "description": "What host IP to bind the external port to.\n+optional"
        },
        "hostPort": {
          "type": "integer",
          "description": "Number of port to expose on the host.\nIf specified, this must be a valid port number, 0 < x < 65536.\nIf HostNetwork is specified, this must match ContainerPort.\nMost containers do not need this.\n+optional"
        },
        "name": {
          "type": "string",
          "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each\nnamed port in a pod must have a unique name. Name for the port that can be\nreferred to by services.\n+optional"
        },
        "protocol": {
          "type": "string",
          "description": "Protocol for port. Must be UDP, TCP, or SCTP.\nDefaults to \"TCP\".\n+optional\n+default=\"TCP\""
        }
      }
    },
    "v1.ContainerResizePolicy": {
      "type": "object",
      "properties": {
        "resourceName": {
          "type": "string",
          "description": "Name of the resource to which this resource resize policy applies.\nSupported values: cpu, memory."
        },
        "restartPolicy": {
          "type": "string",
          "description": "Restart policy to apply when specified resource is resized.\nIf not specified, it defaults to NotRequired."
        }
      }
    },
    "v1.Duration": {
      "type": "object",
      "properties": {
        "time.Duration": {
          "type": "integer"
        }
      }
    },
    "v1.EnvFromSource": {
      "type": "object",
      "properties": {
        "configMapRef": {
          "description": "The ConfigMap to select from\n+optional",
          "$ref": "#/definitions/v1.ConfigMapEnvSource"
        },
        "prefix": {
          "type": "string",
          "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.\n+optional"
        },
        "secretRef": {
          "description": "The Secret to select from\n+optional",
          "$ref": "#/definitions/v1.SecretEnvSource"
        }
      }
    },
    "v1.EnvVar": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the environment variable. Must be a C_IDENTIFIER."
        },
        "value": {
          "type": "string",
          "description": "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".\n+optional"
        },
        "valueFrom": {
          "description": "Source for the environment variable's value. Cannot be used if value is not empty.\n+optional",
          "$ref": "#/definitions/v1.EnvVarSource"
        }
      }
    },
    "v1.EnvVarSource": {
      "type": "object",
      "properties": {
        "configMapKeyRef": {
          "description": "Selects a key of a ConfigMap.\n+optional",
          "$ref": "#/definitions/v1.ConfigMapKeySelector"
        },
        "fieldRef": {
          "description": "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.\n+optional",
          "$ref": "#/definitions/v1.ObjectFieldSelector"
        },
        "resourceFieldRef": {
          "description": "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.\n+optional",
          "$ref": "#/definitions/v1.ResourceFieldSelector"
        },
        "secretKeyRef": {
          "description": "Selects a key of a secret in the pod's namespace\n+optional",
          "$ref": "#/definitions/v1.SecretKeySelector"
        }
      }
    },
    "v1.ExecAction": {
      "type": "object",
      "properties": {
        "command": {
          "type": "array",
          "description": "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.\n+optional",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "v1.FieldsV1": {
      "type": "object"
    },
    "v1.GRPCAction": {
      "type": "object",
      "properties": {
        "port": {
          "type": "integer",
          "description": "Port number of the gRPC service. Number must be in the range 1 to 65535."
        },
        "service": {
          "type": "string",
          "description": "Service is the name of the service to place in the gRPC HealthCheckRequest\n(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf this is not specified, the default behavior is defined by gRPC.\n+optional\n+default=\"\""
        }
      }
    },
    "v1.HTTPGetAction": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "description": "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.\n+optional"
        },
        "httpHeaders": {
          "type": "array",
          "description": "Custom headers to set in the request. HTTP allows repeated headers.\n+optional",
          "items": {
            "$ref": "#/definitions/v1.HTTPHeader"
          }
        },
        "path": {
          "type": "string",
          "description": "Path to access on the HTTP server.\n+optional"
        },
        "port": {
          "description": "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
          "$ref": "#/definitions/intstr.IntOrString"
        },
        "scheme": {
          "type": "string",
          "description": "Scheme to use for connecting to the host.\nDefaults to HTTP.\n+optional"
        }
      }
    },
    "v1.HTTPHeader": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header."
        },
        "value": {
          "type": "string",
          "description": "The header field value"
        }
      }
    },
    "v1.LabelSelector": {
      "type": "object",
      "properties": {
        "matchExpressions": {
          "type": "array",
          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+optional",
          "items": {
            "$ref": "#/definitions/v1.LabelSelectorRequirement"
          }
        },
        "matchLabels": {
          "type": "object",
          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "v1.LabelSelectorRequirement": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "key is the label key that the selector applies to."
        },
        "operator": {
          "type": "string",
          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist."
        },
        "values": {
          "type": "array",
          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.\n+optional",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "v1.Lifecycle": {
      "type": "object",
      "properties": {
        "postStart": {
          "description": "PostStart is called immediately after a container is created. If the handler fails,\nthe container is terminated and restarted according to its restart policy.\nOther management of the container blocks until the hook completes.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks\n+optional",
          "$ref": "#/definitions/v1.LifecycleHandler"
        },
        "preStop": {
          "description": "PreStop is called immediately before a container is terminated due to an\nAPI request or management event such as liveness/startup probe failure,\npreemption, resource contention, etc. The handler is not called if the\ncontainer crashes or exits. The Pod's termination grace period countdown begins before the\nPreStop hook is executed. Regardless of the outcome of the handler, the\ncontainer will eventually terminate within the Pod's termination grace\nperiod (unless delayed by finalizers). Other management of the container blocks until the hook completes\nor until the termination grace period is reached.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks\n+optional",
          "$ref": "#/definitions/v1.LifecycleHandler"
        }
      }
    },
    "v1.LifecycleHandler": {
      "type": "object",
      "properties": {
        "exec": {
          "description": "Exec specifies the action to take.\n+optional",
          "$ref": "#/definitions/v1.ExecAction"
        },
        "httpGet": {
          "description": "HTTPGet specifies the http request to perform.\n+optional",
          "$ref": "#/definitions/v1.HTTPGetAction"
        },
        "sleep": {
          "description": "Sleep represents the duration that the container should sleep before being terminated.\n+featureGate=PodLifecycleSleepAction\n+optional",
          "$ref": "#/definitions/v1.SleepAction"
        },
        "tcpSocket": {
          "description": "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept\nfor the backward compatibility. There are no validation of this field and\nlifecycle hooks will fail in runtime when tcp handler is specified.\n+optional",
          "$ref": "#/definitions/v1.TCPSocketAction"
        }
      }
    },
    "v1.LoadBalancerIngress": {
      "type": "object",
      "properties": {
        "hostname": {
          "type": "string",
          "description": "Hostname is set for load-balancer ingress points that are DNS based\n(typically AWS load-balancers)\n+optional"
        },
        "ip": {
          "type": "string",
          "description": "IP is set for load-balancer ingress points that are IP based\n(typically GCE or OpenStack load-balancers)\n+optional"
        },
        "ipMode": {
          "type": "string",
          "description": "IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.\nSetting this to \"VIP\" indicates that traffic is delivered to the node with\nthe destination set to the load-balancer's IP and port.\nSetting this to \"Proxy\" indicates that traffic is delivered to the node or pod with\nthe destination set to the node's IP and node port or the pod's IP and port.\nService implementations may use this information to adjust traffic routing.\n+optional"
        },
        "ports": {
          "type": "array",
          "description": "Ports is a list of records of service ports\nIf used, every port defined in the service should have an entry in it\n+listType=atomic\n+optional",
          "items": {
            "$ref": "#/definitions/v1.PortStatus"
          }
        }
      }
    },
    "v1.LoadBalancerStatus": {
      "type": "object",
      "properties": {
        "ingress": {
          "type": "array",
          "description": "Ingress is a list containing ingress points for the load-balancer.\nTraffic intended for the service should be sent to these ingress points.\n+optional",
          "items": {
            "$ref": "#/definitions/v1.LoadBalancerIngress"
          }
        }
      }
    },
    "v1.ManagedFieldsEntry": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the version of this resource that this field set\napplies to. The format is \"group/version\" just like the top-level\nAPIVersion field. It is necessary to track the version of a field\nset because it cannot be automatically converted."
        },
        "fieldsType": {
          "type": "string",
          "description": "FieldsType is the discriminator for the different fields format and version.\nThere is currently only one possible value: \"FieldsV1\""
        },
        "fieldsV1": {
          "description": "FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.\n+optional",
          "$ref": "#/definitions/v1.FieldsV1"
        },
        "manager": {
          "type": "string",
          "description": "Manager is an identifier of the workflow managing these fields."
        },
        "operation": {
          "type": "string",
          "description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created.\nThe only valid values for this field are 'Apply' and 'Update'."
        },
        "subresource": {
          "type": "string",
          "description": "Subresource is the name of the subresource used to update that object, or\nempty string if the object was updated through the main resource. The\nvalue of this field is used to distinguish between managers, even if they\nshare the same name. For example, a status update will be distinct from a\nregular update using the same manager name.\nNote that the APIVersion field is not related to the Subresource field and\nit always corresponds to the version of the main resource."
        },
        "time": {
          "type": "string",
          "description": "Time is the timestamp of when the ManagedFields entry was added. The\ntimestamp will also be updated if a field is added, the manager\nchanges any of the owned fields value or removes a field. The\ntimestamp does not update when a field is removed from the entry\nbecause another manager took it over.\n+optional"
        }
      }
    },
    "v1.NamespaceCondition": {
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "type": "string",
          "description": "+optional"
        },
        "message": {
          "type": "string",
          "description": "+optional"
        },
        "reason": {
          "type": "string",
          "description": "+optional"
        },
        "status": {
          "type": "string",
          "description": "Status of the condition, one of True, False, Unknown."
        },
        "type": {
          "type": "string",
          "description": "Type of namespace controller condition."
        }
      }
    },
    "v1.NamespaceStatus": {
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "description": "Represents the latest available observations of a namespace's current state.\n+optional\n+patchMergeKey=type\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.NamespaceCondition"
          }
        },
        "phase": {
          "type": "string",
          "description": "Phase is the current lifecycle phase of the namespace.\nMore info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/\n+optional"
        }
      }
    },
    "v1.ObjectFieldSelector": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".\n+optional"
        },
        "fieldPath": {
          "type": "string",
          "description": "Path of the field to select in the specified API version."
        }
      }
    },
    "v1.ObjectReference": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "API version of the referent.\n+optional"
        },
        "fieldPath": {
          "type": "string",
          "description": "If referring to a piece of an object instead of an entire object, this string\nshould contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\nFor example, if the object reference is to a container within a pod, this would take on a value like:\n\"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered\nthe event) or if no container name is specified \"spec.containers[2]\" (container with\nindex 2 in this pod). This syntax is chosen only to have some well-defined way of\nreferencing a part of an object.\nTODO: this design is not final and this field is subject to change in the future.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n+optional"
        },
        "resourceVersion": {
          "type": "string",
          "description": "Specific resourceVersion to which this reference is made, if any.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\n+optional"
        }
      }
    },
    "v1.OwnerReference": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "API version of the referent."
        },
        "blockOwnerDeletion": {
          "type": "boolean",
          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then\nthe owner cannot be deleted from the key-value store until this\nreference is removed.\nSee https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion\nfor how the garbage collector interacts with this field and enforces the foreground deletion.\nDefaults to false.\nTo set this field, a user needs \"delete\" permission of the owner,\notherwise 422 (Unprocessable Entity) will be returned.\n+optional"
        },
        "controller": {
          "type": "boolean",
          "description": "If true, this reference points to the managing controller.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        },
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
        },
        "uid": {
          "type": "string",
          "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
        }
      }
    },
    "v1.PortStatus": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string",
          "description": "Error is to record the problem with the service port\nThe format of the error shall comply with the following rules:\n- built-in error values shall be specified in this file and those shall use\n  CamelCase names\n- cloud provider specific error values must have names that comply with the\n  format foo.example.com/CamelCase.\n---\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n+optional\n+kubebuilder:validation:Required\n+kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`\n+kubebuilder:validation:MaxLength=316"
        },
        "port": {
          "type": "integer",
          "description": "Port is the port number of the service port of which status is recorded here"
        },
        "protocol": {
          "type": "string",
          "description": "Protocol is the protocol of the service port of which status is recorded here\nThe supported values are: \"TCP\", \"UDP\", \"SCTP\""
        }
      }
    },
    "v1.Probe": {
      "type": "object",
      "properties": {
        "exec": {
          "description": "Exec specifies the action to take.\n+optional",
          "$ref": "#/definitions/v1.ExecAction"
        },
        "failureThreshold": {
          "type": "integer",
          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded.\nDefaults to 3. Minimum value is 1.\n+optional"
        },
        "grpc": {
          "description": "GRPC specifies an action involving a GRPC port.\n+optional",
          "$ref": "#/definitions/v1.GRPCAction"
        },
        "httpGet": {
          "description": "HTTPGet specifies the http request to perform.\n+optional",
          "$ref": "#/definitions/v1.HTTPGetAction"
        },
        "initialDelaySeconds": {
          "type": "integer",
          "description": "Number of seconds after the container has started before liveness probes are initiated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\n+optional"
        },
        "periodSeconds": {
          "type": "integer",
          "description": "How often (in seconds) to perform the probe.\nDefault to 10 seconds. Minimum value is 1.\n+optional"
        },
        "successThreshold": {
          "type": "integer",
          "description": "Minimum consecutive successes for the probe to be considered successful after having failed.\nDefaults to 1. Must be 1 for liveness and startup. Minimum value is 1.\n+optional"
        },
        "tcpSocket": {
          "description": "TCPSocket specifies an action involving a TCP port.\n+optional",
          "$ref": "#/definitions/v1.TCPSocketAction"
        },
        "terminationGracePeriodSeconds": {
          "type": "integer",
          "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure.\nThe grace period is the duration in seconds after the processes running in the pod are sent\na termination signal and the time when the processes are forcibly halted with a kill signal.\nSet this value longer than the expected cleanup time for your process.\nIf this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this\nvalue overrides the value provided by the pod spec.\nValue must be non-negative integer. The value zero indicates stop immediately via\nthe kill signal (no opportunity to shut down).\nThis is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.\nMinimum value is 1. spec.terminationGracePeriodSeconds is used if unset.\n+optional"
        },
        "timeoutSeconds": {
          "type": "integer",
          "description": "Number of seconds after which the probe times out.\nDefaults to 1 second. Minimum value is 1.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes\n+optional"
        }
      }
    },
    "v1.ResourceClaim": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container."
        }
      }
    },
    "v1.ResourceFieldSelector": {
      "type": "object",
      "properties": {
        "containerName": {
          "type": "string",
          "description": "Container name: required for volumes, optional for env vars\n+optional"
        },
        "divisor": {
          "description": "Specifies the output format of the exposed resources, defaults to \"1\"\n+optional",
          "$ref": "#/definitions/resource.Quantity"
        },
        "resource": {
          "type": "string",
          "description": "Required: resource to select"
        }
      }
    },
    "v1.ResourceList": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/resource.Quantity"
      }
    },
    "v1.ResourceQuota": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "creationTimestamp": {
          "type": "string",
          "description": "CreationTimestamp is a timestamp representing the server time when this object was\ncreated. It is not guaranteed to be set in happens-before order across separate operations.\nClients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionGracePeriodSeconds": {
          "type": "integer",
          "description": "Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\nfield is set by the server when a graceful deletion is requested by the user, and is not\ndirectly settable by a client. The resource is expected to be deleted (no longer visible\nfrom resource lists, and not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\nOnce the deletionTimestamp is set, this value may not be unset or be set further into the\nfuture, although it may be shortened or the resource may be deleted prior to this time.\nFor example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\nby sending a graceful termination signal to the containers in the pod. After that 30 seconds,\nthe Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\nremove the pod from the API. In the presence of network partitions, this object may still\nexist after this timestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "finalizers": {
          "type": "array",
          "description": "Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge",
          "items": {
            "type": "string"
          }
        },
        "generateName": {
          "type": "string",
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional"
        },
        "generation": {
          "type": "integer",
          "description": "A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "labels": {
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "type": "array",
          "description": "ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n\"ci-cd\". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to the \"default\" namespace, but \"default\" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces\n+optional"
        },
        "ownerReferences": {
          "type": "array",
          "description": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.OwnerReference"
          }
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        },
        "spec": {
          "description": "Spec defines the desired quota.\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n+optional",
          "$ref": "#/definitions/v1.ResourceQuotaSpec"
        },
        "status": {
          "description": "Status defines the actual enforced quota and its current usage.\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n+optional",
          "$ref": "#/definitions/v1.ResourceQuotaStatus"
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids\n+optional"
        }
      }
    },
    "v1.ResourceQuotaSpec": {
      "type": "object",
      "properties": {
        "hard": {
          "description": "hard is the set of desired hard limits for each named resource.\nMore info: https://kubernetes.io/docs/concepts/policy/resource-quotas/\n+optional",
          "$ref": "#/definitions/v1.ResourceList"
        },
        "scopeSelector": {
          "description": "scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota\nbut expressed using ScopeSelectorOperator in combination with possible values.\nFor a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.\n+optional",
          "$ref": "#/definitions/v1.ScopeSelector"
        },
        "scopes": {
          "type": "array",
          "description": "A collection of filters that must match each object tracked by a quota.\nIf not specified, the quota matches all objects.\n+optional",
          "items": {
            "type": "string",
            "description": "The name of the scope that the selector applies to."
          }
        }
      }
    },
    "v1.ResourceQuotaStatus": {
      "type": "object",
      "properties": {
        "hard": {
          "description": "Hard is the set of enforced hard limits for each named resource.\nMore info: https://kubernetes.io/docs/concepts/policy/resource-quotas/\n+optional",
          "$ref": "#/definitions/v1.ResourceList"
        },
        "used": {
          "description": "Used is the current observed total usage of the resource in the namespace.\n+optional",
          "$ref": "#/definitions/v1.ResourceList"
        }
      }
    },
    "v1.ResourceRequirements": {
      "type": "object",
      "properties": {
        "claims": {
          "type": "array",
          "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.\n\n+listType=map\n+listMapKey=name\n+featureGate=DynamicResourceAllocation\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ResourceClaim"
          }
        },
        "limits": {
          "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional",
          "$ref": "#/definitions/v1.ResourceList"
        },
        "requests": {
          "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional",
          "$ref": "#/definitions/v1.ResourceList"
        }
      }
    },
    "v1.RoleRef": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "type": "string",
          "description": "APIGroup is the group for the resource being referenced"
        },
        "kind": {
          "type": "string",
          "description": "Kind is the type of resource being referenced"
        },
        "name": {
          "type": "string",
          "description": "Name is the name of resource being referenced"
        }
      }
    },
    "v1.SELinuxOptions": {
      "type": "object",
      "properties": {
        "level": {
          "type": "string",
          "description": "Level is SELinux level label that applies to the container.\n+optional"
        },
        "role": {
          "type": "string",
          "description": "Role is a SELinux role label that applies to the container.\n+optional"
        },
        "type": {
          "type": "string",
          "description": "Type is a SELinux type label that applies to the container.\n+optional"
        },
        "user": {
          "type": "string",
          "description": "User is a SELinux user label that applies to the container.\n+optional"
        }
      }
    },
    "v1.ScopeSelector": {
      "type": "object",
      "properties": {
        "matchExpressions": {
          "type": "array",
          "description": "A list of scope selector requirements by scope of the resources.\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ScopedResourceSelectorRequirement"
          }
        }
      }
    },
    "v1.ScopedResourceSelectorRequirement": {
      "type": "object",
      "properties": {
        "operator": {
          "type": "string",
          "description": "Represents a scope's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist."
        },
        "scopeName": {
          "type": "string",
          "description": "The name of the scope that the selector applies to."
        },
        "values": {
          "type": "array",
          "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty.\nThis array is replaced during a strategic merge patch.\n+optional",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "v1.SeccompProfile": {
      "type": "object",
      "properties": {
        "localhostProfile": {
          "type": "string",
          "description": "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.\n+optional"
        },
        "type": {
          "type": "string",
          "description": "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.\n+unionDiscriminator"
        }
      }
    },
    "v1.SecretEnvSource": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO: Add other useful fields. apiVersion, kind, uid?\n+optional"
        },
        "optional": {
          "type": "boolean",
          "description": "Specify whether the Secret must be defined\n+optional"
        }
      }
    },
    "v1.SecretKeySelector": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key of the secret to select from.  Must be a valid secret key."
        },
        "name": {
          "type": "string",
          "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO: Add other useful fields. apiVersion, kind, uid?\n+optional"
        },
        "optional": {
          "type": "boolean",
          "description": "Specify whether the Secret or its key must be defined\n+optional"
        }
      }
    },
    "v1.SecretReference": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name is unique within a namespace to reference a secret resource.\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "namespace defines the space within which the secret name must be unique.\n+optional"
        }
      }
    },
    "v1.SecurityContext": {
      "type": "object",
      "properties": {
        "allowPrivilegeEscalation": {
          "type": "boolean",
          "description": "AllowPrivilegeEscalation controls whether a process can gain more\nprivileges than its parent process. This bool directly controls if\nthe no_new_privs flag will be set on the container process.\nAllowPrivilegeEscalation is true always when the container is:\n1) run as Privileged\n2) has CAP_SYS_ADMIN\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "capabilities": {
          "description": "The capabilities to add/drop when running containers.\nDefaults to the default set of capabilities granted by the container runtime.\nNote that this field cannot be set when spec.os.name is windows.\n+optional",
          "$ref": "#/definitions/v1.Capabilities"
        },
        "privileged": {
          "type": "boolean",
          "description": "Run container in privileged mode.\nProcesses in privileged containers are essentially equivalent to root on the host.\nDefaults to false.\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "procMount": {
          "type": "string",
          "description": "procMount denotes the type of proc mount to use for the containers.\nThe default is DefaultProcMount which uses the container runtime defaults for\nreadonly paths and masked paths.\nThis requires the ProcMountType feature flag to be enabled.\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "readOnlyRootFilesystem": {
          "type": "boolean",
          "description": "Whether this container has a read-only root filesystem.\nDefault is false.\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "runAsGroup": {
          "type": "integer",
          "description": "The GID to run the entrypoint of the container process.\nUses runtime default if unset.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "runAsNonRoot": {
          "type": "boolean",
          "description": "Indicates that the container must run as a non-root user.\nIf true, the Kubelet will validate the image at runtime to ensure that it\ndoes not run as UID 0 (root) and fail to start the container if it does.\nIf unset or false, no such validation will be performed.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\n+optional"
        },
        "runAsUser": {
          "type": "integer",
          "description": "The UID to run the entrypoint of the container process.\nDefaults to user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.\n+optional"
        },
        "seLinuxOptions": {
          "description": "The SELinux context to be applied to the container.\nIf unspecified, the container runtime will allocate a random SELinux context for each\ncontainer.  May also be set in PodSecurityContext.  If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is windows.\n+optional",
          "$ref": "#/definitions/v1.SELinuxOptions"
        },
        "seccompProfile": {
          "description": "The seccomp options to use by this container. If seccomp options are\nprovided at both the pod & container level, the container options\noverride the pod options.\nNote that this field cannot be set when spec.os.name is windows.\n+optional",
          "$ref": "#/definitions/v1.SeccompProfile"
        },
        "windowsOptions": {
          "description": "The Windows specific settings applied to all containers.\nIf unspecified, the options from the PodSecurityContext will be used.\nIf set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.\nNote that this field cannot be set when spec.os.name is linux.\n+optional",
          "$ref": "#/definitions/v1.WindowsSecurityContextOptions"
        }
      }
    },
    "v1.Service": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "creationTimestamp": {
          "type": "string",
          "description": "CreationTimestamp is a timestamp representing the server time when this object was\ncreated. It is not guaranteed to be set in happens-before order across separate operations.\nClients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionGracePeriodSeconds": {
          "type": "integer",
          "description": "Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\nfield is set by the server when a graceful deletion is requested by the user, and is not\ndirectly settable by a client. The resource is expected to be deleted (no longer visible\nfrom resource lists, and not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\nOnce the deletionTimestamp is set, this value may not be unset or be set further into the\nfuture, although it may be shortened or the resource may be deleted prior to this time.\nFor example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\nby sending a graceful termination signal to the containers in the pod. After that 30 seconds,\nthe Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\nremove the pod from the API. In the presence of network partitions, this object may still\nexist after this timestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "finalizers": {
          "type": "array",
          "description": "Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge",
          "items": {
            "type": "string"
          }
        },
        "generateName": {
          "type": "string",
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional"
        },
        "generation": {
          "type": "integer",
          "description": "A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "labels": {
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "type": "array",
          "description": "ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n\"ci-cd\". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to the \"default\" namespace, but \"default\" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces\n+optional"
        },
        "ownerReferences": {
          "type": "array",
          "description": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.OwnerReference"
          }
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        },
        "spec": {
          "description": "Spec defines the behavior of a service.\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n+optional",
          "$ref": "#/definitions/v1.ServiceSpec"
        },
        "status": {
          "description": "Most recently observed status of the service.\nPopulated by the system.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n+optional",
          "$ref": "#/definitions/v1.ServiceStatus"
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids\n+optional"
        }
      }
    },
    "v1.ServicePort": {
      "type": "object",
      "properties": {
        "appProtocol": {
          "type": "string",
          "description": "The application protocol for this port.\nThis is used as a hint for implementations to offer richer behavior for protocols that they understand.\nThis field follows standard Kubernetes label syntax.\nValid values are either:\n\n* Un-prefixed protocol names - reserved for IANA standard service names (as per\nRFC-6335 and https://www.iana.org/assignments/service-names).\n\n* Kubernetes-defined prefixed names:\n  * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-\n  * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455\n  * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455\n\n* Other protocols should use implementation-defined prefixed names such as\nmycompany.com/my-custom-protocol.\n+optional"
        },
        "name": {
          "type": "string",
          "description": "The name of this port within the service. This must be a DNS_LABEL.\nAll ports within a ServiceSpec must have unique names. When considering\nthe endpoints for a Service, this must match the 'name' field in the\nEndpointPort.\nOptional if only one ServicePort is defined on this service.\n+optional"
        },
        "nodePort": {
          "type": "integer",
          "description": "The port on each node on which this service is exposed when type is\nNodePort or LoadBalancer.  Usually assigned by the system. If a value is\nspecified, in-range, and not in use it will be used, otherwise the\noperation will fail.  If not specified, a port will be allocated if this\nService requires one.  If this field is specified when creating a\nService which does not need it, creation will fail. This field will be\nwiped when updating a Service to no longer need it (e.g. changing type\nfrom NodePort to ClusterIP).\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport\n+optional"
        },
        "port": {
          "type": "integer",
          "description": "The port that will be exposed by this service."
        },
        "protocol": {
          "type": "string",
          "description": "The IP protocol for this port. Supports \"TCP\", \"UDP\", and \"SCTP\".\nDefault is TCP.\n+default=\"TCP\"\n+optional"
        },
        "targetPort": {
          "description": "Number or name of the port to access on the pods targeted by the service.\nNumber must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.\nIf this is a string, it will be looked up as a named port in the\ntarget Pod's container ports. If this is not specified, the value\nof the 'port' field is used (an identity map).\nThis field is ignored for services with clusterIP=None, and should be\nomitted or set equal to the 'port' field.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service\n+optional",
          "$ref": "#/definitions/intstr.IntOrString"
        }
      }
    },
    "v1.ServiceSpec": {
      "type": "object",
      "properties": {
        "allocateLoadBalancerNodePorts": {
          "type": "boolean",
          "description": "allocateLoadBalancerNodePorts defines if NodePorts will be automatically\nallocated for services with type LoadBalancer.  Default is \"true\". It\nmay be set to \"false\" if the cluster load-balancer does not rely on\nNodePorts.  If the caller requests specific NodePorts (by specifying a\nvalue), those requests will be respected, regardless of this field.\nThis field may only be set for services with type LoadBalancer and will\nbe cleared if the type is changed to any other type.\n+optional"
        },
        "clusterIP": {
          "type": "string",
          "description": "clusterIP is the IP address of the service and is usually assigned\nrandomly. If an address is specified manually, is in-range (as per\nsystem configuration), and is not in use, it will be allocated to the\nservice; otherwise creation of the service will fail. This field may not\nbe changed through updates unless the type field is also being changed\nto ExternalName (which requires this field to be blank) or the type\nfield is being changed from ExternalName (in which case this field may\noptionally be specified, as describe above).  Valid values are \"None\",\nempty string (\"\"), or a valid IP address. Setting this to \"None\" makes a\n\"headless service\" (no virtual IP), which is useful when direct endpoint\nconnections are preferred and proxying is not required.  Only applies to\ntypes ClusterIP, NodePort, and LoadBalancer. If this field is specified\nwhen creating a Service of type ExternalName, creation will fail. This\nfield will be wiped when updating a Service to type ExternalName.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+optional"
        },
        "clusterIPs": {
          "type": "array",
          "description": "ClusterIPs is a list of IP addresses assigned to this service, and are\nusually assigned randomly.  If an address is specified manually, is\nin-range (as per system configuration), and is not in use, it will be\nallocated to the service; otherwise creation of the service will fail.\nThis field may not be changed through updates unless the type field is\nalso being changed to ExternalName (which requires this field to be\nempty) or the type field is being changed from ExternalName (in which\ncase this field may optionally be specified, as describe above).  Valid\nvalues are \"None\", empty string (\"\"), or a valid IP address.  Setting\nthis to \"None\" makes a \"headless service\" (no virtual IP), which is\nuseful when direct endpoint connections are preferred and proxying is\nnot required.  Only applies to types ClusterIP, NodePort, and\nLoadBalancer. If this field is specified when creating a Service of type\nExternalName, creation will fail. This field will be wiped when updating\na Service to type ExternalName.  If this field is not specified, it will\nbe initialized from the clusterIP field.  If this field is specified,\nclients must ensure that clusterIPs[0] and clusterIP have the same\nvalue.\n\nThis field may hold a maximum of two entries (dual-stack IPs, in either order).\nThese IPs must correspond to the values of the ipFamilies field. Both\nclusterIPs and ipFamilies are governed by the ipFamilyPolicy field.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+listType=atomic\n+optional",
          "items": {
            "type": "string"
          }
        },
        "externalIPs": {
          "type": "array",
          "description": "externalIPs is a list of IP addresses for which nodes in the cluster\nwill also accept traffic for this service.  These IPs are not managed by\nKubernetes.  The user is responsible for ensuring that traffic arrives\nat a node with this IP.  A common example is external load-balancers\nthat are not part of the Kubernetes system.\n+optional",
          "items": {
            "type": "string"
          }
        },
        "externalName": {
          "type": "string",
          "description": "externalName is the external reference that discovery mechanisms will\nreturn as an alias for this service (e.g. a DNS CNAME record). No\nproxying will be involved.  Must be a lowercase RFC-1123 hostname\n(https://tools.ietf.org/html/rfc1123) and requires `type` to be \"ExternalName\".\n+optional"
        },
        "externalTrafficPolicy": {
          "type": "string",
          "description": "externalTrafficPolicy describes how nodes distribute service traffic they\nreceive on one of the Service's \"externally-facing\" addresses (NodePorts,\nExternalIPs, and LoadBalancer IPs). If set to \"Local\", the proxy will configure\nthe service in a way that assumes that external load balancers will take care\nof balancing the service traffic between nodes, and so each node will deliver\ntraffic only to the node-local endpoints of the service, without masquerading\nthe client source IP. (Traffic mistakenly sent to a node with no endpoints will\nbe dropped.) The default value, \"Cluster\", uses the standard behavior of\nrouting to all endpoints evenly (possibly modified by topology and other\nfeatures). Note that traffic sent to an External IP or LoadBalancer IP from\nwithin the cluster will always get \"Cluster\" semantics, but clients sending to\na NodePort from within the cluster may need to take traffic policy into account\nwhen picking a node.\n+optional"
        },
        "healthCheckNodePort": {
          "type": "integer",
          "description": "healthCheckNodePort specifies the healthcheck nodePort for the service.\nThis only applies when type is set to LoadBalancer and\nexternalTrafficPolicy is set to Local. If a value is specified, is\nin-range, and is not in use, it will be used.  If not specified, a value\nwill be automatically allocated.  External systems (e.g. load-balancers)\ncan use this port to determine if a given node holds endpoints for this\nservice or not.  If this field is specified when creating a Service\nwhich does not need it, creation will fail. This field will be wiped\nwhen updating a Service to no longer need it (e.g. changing type).\nThis field cannot be updated once set.\n+optional"
        },
        "internalTrafficPolicy": {
          "type": "string",
          "description": "InternalTrafficPolicy describes how nodes distribute service traffic they\nreceive on the ClusterIP. If set to \"Local\", the proxy will assume that pods\nonly want to talk to endpoints of the service on the same node as the pod,\ndropping the traffic if there are no local endpoints. The default value,\n\"Cluster\", uses the standard behavior of routing to all endpoints evenly\n(possibly modified by topology and other features).\n+optional"
        },
        "ipFamilies": {
          "type": "array",
          "description": "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this\nservice. This field is usually assigned automatically based on cluster\nconfiguration and the ipFamilyPolicy field. If this field is specified\nmanually, the requested family is available in the cluster,\nand ipFamilyPolicy allows it, it will be used; otherwise creation of\nthe service will fail. This field is conditionally mutable: it allows\nfor adding or removing a secondary IP family, but it does not allow\nchanging the primary IP family of the Service. Valid values are \"IPv4\"\nand \"IPv6\".  This field only applies to Services of types ClusterIP,\nNodePort, and LoadBalancer, and does apply to \"headless\" services.\nThis field will be wiped when updating a Service to type ExternalName.\n\nThis field may hold a maximum of two entries (dual-stack families, in\neither order).  These families must correspond to the values of the\nclusterIPs field, if specified. Both clusterIPs and ipFamilies are\ngoverned by the ipFamilyPolicy field.\n+listType=atomic\n+optional",
          "items": {
            "type": "string"
          }
        },
        "ipFamilyPolicy": {
          "type": "string",
          "description": "IPFamilyPolicy represents the dual-stack-ness requested or required by\nthis Service. If there is no value provided, then this field will be set\nto SingleStack. Services can be \"SingleStack\" (a single IP family),\n\"PreferDualStack\" (two IP families on dual-stack configured clusters or\na single IP family on single-stack clusters), or \"RequireDualStack\"\n(two IP families on dual-stack configured clusters, otherwise fail). The\nipFamilies and clusterIPs fields depend on the value of this field. This\nfield will be wiped when updating a service to type ExternalName.\n+optional"
        },
        "loadBalancerClass": {
          "type": "string",
          "description": "loadBalancerClass is the class of the load balancer implementation this Service belongs to.\nIf specified, the value of this field must be a label-style identifier, with an optional prefix,\ne.g. \"internal-vip\" or \"example.com/internal-vip\". Unprefixed names are reserved for end-users.\nThis field can only be set when the Service type is 'LoadBalancer'. If not set, the default load\nbalancer implementation is used, today this is typically done through the cloud provider integration,\nbut should apply for any default implementation. If set, it is assumed that a load balancer\nimplementation is watching for Services with a matching class. Any default load balancer\nimplementation (e.g. cloud providers) should ignore Services that set this field.\nThis field can only be set when creating or updating a Service to type 'LoadBalancer'.\nOnce set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.\n+optional"
        },
        "loadBalancerIP": {
          "type": "string",
          "description": "Only applies to Service Type: LoadBalancer.\nThis feature depends on whether the underlying cloud-provider supports specifying\nthe loadBalancerIP when a load balancer is created.\nThis field will be ignored if the cloud-provider does not support the feature.\nDeprecated: This field was under-specified and its meaning varies across implementations.\nUsing it is non-portable and it may not support dual-stack.\nUsers are encouraged to use implementation-specific annotations when available.\n+optional"
        },
        "loadBalancerSourceRanges": {
          "type": "array",
          "description": "If specified and supported by the platform, this will restrict traffic through the cloud-provider\nload-balancer will be restricted to the specified client IPs. This field will be ignored if the\ncloud-provider does not support the feature.\"\nMore info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/\n+optional",
          "items": {
            "type": "string"
          }
        },
        "ports": {
          "type": "array",
          "description": "The list of ports that are exposed by this service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+patchMergeKey=port\n+patchStrategy=merge\n+listType=map\n+listMapKey=port\n+listMapKey=protocol",
          "items": {
            "$ref": "#/definitions/v1.ServicePort"
          }
        },
        "publishNotReadyAddresses": {
          "type": "boolean",
          "description": "publishNotReadyAddresses indicates that any agent which deals with endpoints for this\nService should disregard any indications of ready/not-ready.\nThe primary use case for setting this field is for a StatefulSet's Headless Service to\npropagate SRV DNS records for its Pods for the purpose of peer discovery.\nThe Kubernetes controllers that generate Endpoints and EndpointSlice resources for\nServices interpret this to mean that all endpoints are considered \"ready\" even if the\nPods themselves are not. Agents which consume only Kubernetes generated endpoints\nthrough the Endpoints or EndpointSlice resources can safely assume this behavior.\n+optional"
        },
        "selector": {
          "type": "object",
          "description": "Route service traffic to pods with label keys and values matching this\nselector. If empty or not present, the service is assumed to have an\nexternal process managing its endpoints, which Kubernetes will not\nmodify. Only applies to types ClusterIP, NodePort, and LoadBalancer.\nIgnored if type is ExternalName.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/\n+optional\n+mapType=atomic",
          "additionalProperties": {
            "type": "string"
          }
        },
        "sessionAffinity": {
          "type": "string",
          "description": "Supports \"ClientIP\" and \"None\". Used to maintain session affinity.\nEnable client IP based session affinity.\nMust be ClientIP or None.\nDefaults to None.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+optional"
        },
        "sessionAffinityConfig": {
          "description": "sessionAffinityConfig contains the configurations of session affinity.\n+optional",
          "$ref": "#/definitions/v1.SessionAffinityConfig"
        },
        "type": {
          "type": "string",
          "description": "type determines how the Service is exposed. Defaults to ClusterIP. Valid\noptions are ExternalName, ClusterIP, NodePort, and LoadBalancer.\n\"ClusterIP\" allocates a cluster-internal IP address for load-balancing\nto endpoints. Endpoints are determined by the selector or if that is not\nspecified, by manual construction of an Endpoints object or\nEndpointSlice objects. If clusterIP is \"None\", no virtual IP is\nallocated and the endpoints are published as a set of endpoints rather\nthan a virtual IP.\n\"NodePort\" builds on ClusterIP and allocates a port on every node which\nroutes to the same endpoints as the clusterIP.\n\"LoadBalancer\" builds on NodePort and creates an external load-balancer\n(if supported in the current cloud) which routes to the same endpoints\nas the clusterIP.\n\"ExternalName\" aliases this service to the specified externalName.\nSeveral other fields do not apply to ExternalName services.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types\n+optional"
        }
      }
    },
    "v1.ServiceStatus": {
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "description": "Current service state\n+optional\n+patchMergeKey=type\n+patchStrategy=merge\n+listType=map\n+listMapKey=type",
          "items": {
            "$ref": "#/definitions/v1.Condition"
          }
        },
        "loadBalancer": {
          "description": "LoadBalancer contains the current status of the load-balancer,\nif one is present.\n+optional",
          "$ref": "#/definitions/v1.LoadBalancerStatus"
        }
      }
    },
    "v1.SessionAffinityConfig": {
      "type": "object",
      "properties": {
        "clientIP": {
          "description": "clientIP contains the configurations of Client IP based session affinity.\n+optional",
          "$ref": "#/definitions/v1.ClientIPConfig"
        }
      }
    },
    "v1.SleepAction": {
      "type": "object",
      "properties": {
        "seconds": {
          "type": "integer",
          "description": "Seconds is the number of seconds to sleep."
        }
      }
    },
    "v1.Subject": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "type": "string",
          "description": "APIGroup holds the API group of the referenced subject.\nDefaults to \"\" for ServiceAccount subjects.\nDefaults to \"rbac.authorization.k8s.io\" for User and Group subjects.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind of object being referenced. Values defined by this API group are \"User\", \"Group\", and \"ServiceAccount\".\nIf the Authorizer does not recognized the kind value, the Authorizer should report an error."
        },
        "name": {
          "type": "string",
          "description": "Name of the object being referenced."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the referenced object.  If the object kind is non-namespace, such as \"User\" or \"Group\", and this value is not empty\nthe Authorizer should report an error.\n+optional"
        }
      }
    },
    "v1.TCPSocketAction": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string",
          "description": "Optional: Host name to connect to, defaults to the pod IP.\n+optional"
        },
        "port": {
          "description": "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
          "$ref": "#/definitions/intstr.IntOrString"
        }
      }
    },
    "v1.VolumeDevice": {
      "type": "object",
      "properties": {
        "devicePath": {
          "type": "string",
          "description": "devicePath is the path inside of the container that the device will be mapped to."
        },
        "name": {
          "type": "string",
          "description": "name must match the name of a persistentVolumeClaim in the pod"
        }
      }
    },
    "v1.VolumeMount": {
      "type": "object",
      "properties": {
        "mountPath": {
          "type": "string",
          "description": "Path within the container at which the volume should be mounted.  Must\nnot contain ':'."
        },
        "mountPropagation": {
          "type": "string",
          "description": "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\n+optional"
        },
        "name": {
          "type": "string",
          "description": "This must match the Name of a Volume."
        },
        "readOnly": {
          "type": "boolean",
          "description": "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.\n+optional"
        },
        "subPath": {
          "type": "string",
          "description": "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).\n+optional"
        },
        "subPathExpr": {
          "type": "string",
          "description": "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.\n+optional"
        }
      }
    },
    "v1.WindowsSecurityContextOptions": {
      "type": "object",
      "properties": {
        "gmsaCredentialSpec": {
          "type": "string",
          "description": "GMSACredentialSpec is where the GMSA admission webhook\n(https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the\nGMSA credential spec named by the GMSACredentialSpecName field.\n+optional"
        },
        "gmsaCredentialSpecName": {
          "type": "string",
          "description": "GMSACredentialSpecName is the name of the GMSA credential spec to use.\n+optional"
        },
        "hostProcess": {
          "type": "boolean",
          "description": "HostProcess determines if a container should be run as a 'Host Process' container.\nAll of a Pod's containers must have the same effective HostProcess value\n(it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).\nIn addition, if HostProcess is true then HostNetwork must also be set to true.\n+optional"
        },
        "runAsUserName": {
          "type": "string",
          "description": "The UserName in Windows to run the entrypoint of the container process.\nDefaults to the user specified in image metadata if unspecified.\nMay also be set in PodSecurityContext. If set in both SecurityContext and\nPodSecurityContext, the value specified in SecurityContext takes precedence.\n+optional"
        }
      }
    },
    "v1beta1.ContainerMetrics": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Container name corresponding to the one from pod.spec.containers."
        },
        "usage": {
          "description": "The memory usage is the memory working set.",
          "$ref": "#/definitions/v1.ResourceList"
        }
      }
    },
    "v1beta1.NodeMetrics": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "creationTimestamp": {
          "type": "string",
          "description": "CreationTimestamp is a timestamp representing the server time when this object was\ncreated. It is not guaranteed to be set in happens-before order across separate operations.\nClients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionGracePeriodSeconds": {
          "type": "integer",
          "description": "Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\nfield is set by the server when a graceful deletion is requested by the user, and is not\ndirectly settable by a client. The resource is expected to be deleted (no longer visible\nfrom resource lists, and not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\nOnce the deletionTimestamp is set, this value may not be unset or be set further into the\nfuture, although it may be shortened or the resource may be deleted prior to this time.\nFor example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\nby sending a graceful termination signal to the containers in the pod. After that 30 seconds,\nthe Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\nremove the pod from the API. In the presence of network partitions, this object may still\nexist after this timestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "finalizers": {
          "type": "array",
          "description": "Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge",
          "items": {
            "type": "string"
          }
        },
        "generateName": {
          "type": "string",
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional"
        },
        "generation": {
          "type": "integer",
          "description": "A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "labels": {
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "type": "array",
          "description": "ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n\"ci-cd\". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to the \"default\" namespace, but \"default\" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces\n+optional"
        },
        "ownerReferences": {
          "type": "array",
          "description": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.OwnerReference"
          }
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        },
        "timestamp": {
          "type": "string",
          "description": "The following fields define time interval from which metrics were\ncollected from the interval [Timestamp-Window, Timestamp]."
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids\n+optional"
        },
        "usage": {
          "description": "The memory usage is the memory working set.",
          "$ref": "#/definitions/v1.ResourceList"
        },
        "window": {
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.NodeMetricsList": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "continue": {
          "type": "string",
          "description": "continue may be set if the user set a limit on the number of items returned, and indicates that\nthe server has more data available. The value is opaque and may be used to issue another request\nto the endpoint that served this list to retrieve the next set of available objects. Continuing a\nconsistent list may not be possible if the server configuration has changed or more than a few\nminutes have passed. The resourceVersion field returned when using this continue value will be\nidentical to the value in the first response, unless you have received this token from an error\nmessage."
        },
        "items": {
          "type": "array",
          "description": "List of node metrics.",
          "items": {
            "$ref": "#/definitions/v1beta1.NodeMetrics"
          }
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "remainingItemCount": {
          "type": "integer",
          "description": "remainingItemCount is the number of subsequent items in the list which are not included in this\nlist response. If the list request contained label or field selectors, then the number of\nremaining items is unknown and the field will be left unset and omitted during serialization.\nIf the list is complete (either because it is not chunking or because this is the last chunk),\nthen there are no more remaining items and this field will be left unset and omitted during\nserialization.\nServers older than v1.15 do not set this field.\nThe intended use of the remainingItemCount is *estimating* the size of a collection. Clients\nshould not rely on the remainingItemCount to be set or to be exact.\n+optional"
        },
        "resourceVersion": {
          "type": "string",
          "description": "String that identifies the server's internal version of this object that\ncan be used by clients to determine when objects have changed.\nValue must be treated as opaque by clients and passed unmodified back to the server.\nPopulated by the system.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        }
      }
    },
    "v1beta1.PodMetrics": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "containers": {
          "type": "array",
          "description": "Metrics for all containers are collected within the same time window.",
          "items": {
            "$ref": "#/definitions/v1beta1.ContainerMetrics"
          }
        },
        "creationTimestamp": {
          "type": "string",
          "description": "CreationTimestamp is a timestamp representing the server time when this object was\ncreated. It is not guaranteed to be set in happens-before order across separate operations.\nClients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionGracePeriodSeconds": {
          "type": "integer",
          "description": "Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\nfield is set by the server when a graceful deletion is requested by the user, and is not\ndirectly settable by a client. The resource is expected to be deleted (no longer visible\nfrom resource lists, and not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\nOnce the deletionTimestamp is set, this value may not be unset or be set further into the\nfuture, although it may be shortened or the resource may be deleted prior to this time.\nFor example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\nby sending a graceful termination signal to the containers in the pod. After that 30 seconds,\nthe Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\nremove the pod from the API. In the presence of network partitions, this object may still\nexist after this timestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "finalizers": {
          "type": "array",
          "description": "Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge",
          "items": {
            "type": "string"
          }
        },
        "generateName": {
          "type": "string",
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional"
        },
        "generation": {
          "type": "integer",
          "description": "A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "labels": {
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "type": "array",
          "description": "ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n\"ci-cd\". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to the \"default\" namespace, but \"default\" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces\n+optional"
        },
        "ownerReferences": {
          "type": "array",
          "description": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.OwnerReference"
          }
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        },
        "timestamp": {
          "type": "string",
          "description": "The following fields define time interval from which metrics were\ncollected from the interval [Timestamp-Window, Timestamp]."
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids\n+optional"
        },
        "window": {
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.PodMetricsList": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "continue": {
          "type": "string",
          "description": "continue may be set if the user set a limit on the number of items returned, and indicates that\nthe server has more data available. The value is opaque and may be used to issue another request\nto the endpoint that served this list to retrieve the next set of available objects. Continuing a\nconsistent list may not be possible if the server configuration has changed or more than a few\nminutes have passed. The resourceVersion field returned when using this continue value will be\nidentical to the value in the first response, unless you have received this token from an error\nmessage."
        },
        "items": {
          "type": "array",
          "description": "List of pod metrics.",
          "items": {
            "$ref": "#/definitions/v1beta1.PodMetrics"
          }
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "remainingItemCount": {
          "type": "integer",
          "description": "remainingItemCount is the number of subsequent items in the list which are not included in this\nlist response. If the list request contained label or field selectors, then the number of\nremaining items is unknown and the field will be left unset and omitted during serialization.\nIf the list is complete (either because it is not chunking or because this is the last chunk),\nthen there are no more remaining items and this field will be left unset and omitted during\nserialization.\nServers older than v1.15 do not set this field.\nThe intended use of the remainingItemCount is *estimating* the size of a collection. Clients\nshould not rely on the remainingItemCount to be set or to be exact.\n+optional"
        },
        "resourceVersion": {
          "type": "string",
          "description": "String that identifies the server's internal version of this object that\ncan be used by clients to determine when objects have changed.\nValue must be treated as opaque by clients and passed unmodified back to the server.\nPopulated by the system.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        }
      }
    },
    "v2.ContainerResourceMetricSource": {
      "type": "object",
      "properties": {
        "container": {
          "type": "string",
          "description": "container is the name of the container in the pods of the scaling target"
        },
        "name": {
          "type": "string",
          "description": "name is the name of the resource in question."
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/v2.MetricTarget"
        }
      }
    },
    "v2.ContainerResourceMetricStatus": {
      "type": "object",
      "properties": {
        "container": {
          "type": "string",
          "description": "container is the name of the container in the pods of the scaling target"
        },
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/v2.MetricValueStatus"
        },
        "name": {
          "type": "string",
          "description": "name is the name of the resource in question."
        }
      }
    },
    "v2.CrossVersionObjectReference": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string",
          "description": "apiVersion is the API version of the referent\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        },
        "name": {
          "type": "string",
          "description": "name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        }
      }
    },
    "v2.ExternalMetricSource": {
      "type": "object",
      "properties": {
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/v2.MetricTarget"
        }
      }
    },
    "v2.ExternalMetricStatus": {
      "type": "object",
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/v2.MetricValueStatus"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        }
      }
    },
    "v2.HPAScalingPolicy": {
      "type": "object",
      "properties": {
        "periodSeconds": {
          "type": "integer",
          "description": "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min)."
        },
        "type": {
          "type": "string",
          "description": "type is used to specify the scaling policy."
        },
        "value": {
          "type": "integer",
          "description": "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero"
        }
      }
    },
    "v2.HPAScalingRules": {
      "type": "object",
      "properties": {
        "policies": {
          "type": "array",
          "description": "policies is a list of potential scaling polices which can be used during scaling.\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid\n+listType=atomic\n+optional",
          "items": {
            "$ref": "#/definitions/v2.HPAScalingPolicy"
          }
        },
        "selectPolicy": {
          "type": "string",
          "description": "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.\n+optional"
        },
        "stabilizationWindowSeconds": {
          "type": "integer",
          "description": "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).\n+optional"
        }
      }
    },
    "v2.HorizontalPodAutoscaler": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "apiVersion": {
          "type": "string",
          "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n+optional"
        },
        "creationTimestamp": {
          "type": "string",
          "description": "CreationTimestamp is a timestamp representing the server time when this object was\ncreated. It is not guaranteed to be set in happens-before order across separate operations.\nClients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionGracePeriodSeconds": {
          "type": "integer",
          "description": "Number of seconds allowed for this object to gracefully terminate before\nit will be removed from the system. Only set when deletionTimestamp is also set.\nMay only be shortened.\nRead-only.\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\nfield is set by the server when a graceful deletion is requested by the user, and is not\ndirectly settable by a client. The resource is expected to be deleted (no longer visible\nfrom resource lists, and not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\nOnce the deletionTimestamp is set, this value may not be unset or be set further into the\nfuture, although it may be shortened or the resource may be deleted prior to this time.\nFor example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\nby sending a graceful termination signal to the containers in the pod. After that 30 seconds,\nthe Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\nremove the pod from the API. In the presence of network partitions, this object may still\nexist after this timestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "finalizers": {
          "type": "array",
          "description": "Must be empty before the object is deleted from the registry. Each entry\nis an identifier for the responsible component that will remove the entry\nfrom the list. If the deletionTimestamp of the object is non-nil, entries\nin this list can only be removed.\nFinalizers may be processed and removed in any order.  Order is NOT enforced\nbecause it introduces significant risk of stuck finalizers.\nfinalizers is a shared field, any actor with permission can reorder it.\nIf the finalizer list is processed in order, then this can lead to a situation\nin which the component responsible for the first finalizer in the list is\nwaiting for a signal (field value, external system, or other) produced by a\ncomponent responsible for a finalizer later in the list, resulting in a deadlock.\nWithout enforced ordering finalizers are free to order amongst themselves and\nare not vulnerable to ordering changes in the list.\n+optional\n+patchStrategy=merge",
          "items": {
            "type": "string"
          }
        },
        "generateName": {
          "type": "string",
          "description": "GenerateName is an optional prefix, used by the server, to generate a unique\nname ONLY IF the Name field has not been provided.\nIf this field is used, the name returned to the client will be different\nthan the name passed. This value will also be combined with a unique suffix.\nThe provided value has the same validation rules as the Name field,\nand may be truncated by the length of the suffix required to make the value\nunique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency\n+optional"
        },
        "generation": {
          "type": "integer",
          "description": "A sequence number representing a specific generation of the desired state.\nPopulated by the system. Read-only.\n+optional"
        },
        "kind": {
          "type": "string",
          "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "labels": {
          "type": "object",
          "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels\n+optional",
          "additionalProperties": {
            "type": "string"
          }
        },
        "managedFields": {
          "type": "array",
          "description": "ManagedFields maps workflow-id and version to the set of fields\nthat are managed by that workflow. This is mostly for internal\nhousekeeping, and users typically shouldn't need to set or\nunderstand this field. A workflow can be the user's name, a\ncontroller's name, or the name of a specific apply path like\n\"ci-cd\". The set of fields is always in the version that the\nworkflow used when modifying the object.\n\n+optional",
          "items": {
            "$ref": "#/definitions/v1.ManagedFieldsEntry"
          }
        },
        "name": {
          "type": "string",
          "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within which each name must be unique. An empty namespace is\nequivalent to the \"default\" namespace, but \"default\" is the canonical representation.\nNot all objects are required to be scoped to a namespace - the value of this field for\nthose objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces\n+optional"
        },
        "ownerReferences": {
          "type": "array",
          "description": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is managed by a controller,\nthen an entry in this list will point to this controller, with the controller field set to true.\nThere cannot be more than one managing controller.\n+optional\n+patchMergeKey=uid\n+patchStrategy=merge",
          "items": {
            "$ref": "#/definitions/v1.OwnerReference"
          }
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that can\nbe used by clients to determine when objects have changed. May be used for optimistic\nconcurrency, change detection, and the watch operation on a resource or set of resources.\nClients must treat these values as opaque and passed unmodified back to the server.\nThey may only be valid for a particular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        },
        "selfLink": {
          "type": "string",
          "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.\n+optional"
        },
        "spec": {
          "description": "spec is the specification for the behaviour of the autoscaler.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.\n+optional",
          "$ref": "#/definitions/v2.HorizontalPodAutoscalerSpec"
        },
        "status": {
          "description": "status is the current information about the autoscaler.\n+optional",
          "$ref": "#/definitions/v2.HorizontalPodAutoscalerStatus"
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically generated by\nthe server on successful creation of a resource and is not allowed to change on PUT\noperations.\n\nPopulated by the system.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids\n+optional"
        }
      }
    },
    "v2.HorizontalPodAutoscalerBehavior": {
      "type": "object",
      "properties": {
        "scaleDown": {
          "description": "scaleDown is scaling policy for scaling Down.\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\n300 second stabilization window (i.e., the highest recommendation for\nthe last 300sec is used).\n+optional",
          "$ref": "#/definitions/v2.HPAScalingRules"
        },
        "scaleUp": {
          "description": "scaleUp is scaling policy for scaling Up.\nIf not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used.\n+optional",
          "$ref": "#/definitions/v2.HPAScalingRules"
        }
      }
    },
    "v2.HorizontalPodAutoscalerCondition": {
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "type": "string",
          "description": "lastTransitionTime is the last time the condition transitioned from\none status to another\n+optional"
        },
        "message": {
          "type": "string",
          "description": "message is a human-readable explanation containing details about\nthe transition\n+optional"
        },
        "reason": {
          "type": "string",
          "description": "reason is the reason for the condition's last transition.\n+optional"
        },
        "status": {
          "type": "string",
          "description": "status is the status of the condition (True, False, Unknown)"
        },
        "type": {
          "type": "string",
          "description": "type describes the current condition"
        }
      }
    },
    "v2.HorizontalPodAutoscalerSpec": {
      "type": "object",
      "properties": {
        "behavior": {
          "description": "behavior configures the scaling behavior of the target\nin both Up and Down directions (scaleUp and scaleDown fields respectively).\nIf not set, the default HPAScalingRules for scale up and scale down are used.\n+optional",
          "$ref": "#/definitions/v2.HorizontalPodAutoscalerBehavior"
        },
        "maxReplicas": {
          "type": "integer",
          "description": "maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.\nIt cannot be less that minReplicas."
        },
        "metrics": {
          "type": "array",
          "description": "metrics contains the specifications for which to use to calculate the\ndesired replica count (the maximum replica count across all metrics will\nbe used).  The desired replica count is calculated multiplying the\nratio between the target value and the current value by the current\nnumber of pods.  Ergo, metrics used must decrease as the pod count is\nincreased, and vice-versa.  See the individual metric source types for\nmore information about how each type of metric must respond.\nIf not set, the default metric will be set to 80% average CPU utilization.\n+listType=atomic\n+optional",
          "items": {
            "$ref": "#/definitions/v2.MetricSpec"
          }
        },
        "minReplicas": {
          "type": "integer",
          "description": "minReplicas is the lower limit for the number of replicas to which the autoscaler\ncan scale down.  It defaults to 1 pod.  minReplicas is allowed to be 0 if the\nalpha feature gate HPAScaleToZero is enabled and at least one Object or External\nmetric is configured.  Scaling is active as long as at least one metric value is\navailable.\n+optional"
        },
        "scaleTargetRef": {
          "description": "scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics\nshould be collected, as well as to actually change the replica count.",
          "$ref": "#/definitions/v2.CrossVersionObjectReference"
        }
      }
    },
    "v2.HorizontalPodAutoscalerStatus": {
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "description": "conditions is the set of conditions required for this autoscaler to scale its target,\nand indicates whether or not those conditions are met.\n+patchMergeKey=type\n+patchStrategy=merge\n+listType=map\n+listMapKey=type\n+optional",
          "items": {
            "$ref": "#/definitions/v2.HorizontalPodAutoscalerCondition"
          }
        },
        "currentMetrics": {
          "type": "array",
          "description": "currentMetrics is the last read state of the metrics used by this autoscaler.\n+listType=atomic\n+optional",
          "items": {
            "$ref": "#/definitions/v2.MetricStatus"
          }
        },
        "currentReplicas": {
          "type": "integer",
          "description": "currentReplicas is current number of replicas of pods managed by this autoscaler,\nas last seen by the autoscaler.\n+optional"
        },
        "desiredReplicas": {
          "type": "integer",
          "description": "desiredReplicas is the desired number of replicas of pods managed by this autoscaler,\nas last calculated by the autoscaler."
        },
        "lastScaleTime": {
          "type": "string",
          "description": "lastScaleTime is the last time the HorizontalPodAutoscaler scaled the number of pods,\nused by the autoscaler to control how often the number of pods is changed.\n+optional"
        },
        "observedGeneration": {
          "type": "integer",
          "description": "observedGeneration is the most recent generation observed by this autoscaler.\n+optional"
        }
      }
    },
    "v2.MetricIdentifier": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name is the name of the given metric"
        },
        "selector": {
          "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.\n+optional",
          "$ref": "#/definitions/v1.LabelSelector"
        }
      }
    },
    "v2.MetricSpec": {
      "type": "object",
      "properties": {
        "containerResource": {
          "description": "containerResource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing a single container in\neach pod of the current scale target (e.g. CPU or memory). Such metrics are\nbuilt in to Kubernetes, and have special scaling options on top of those\navailable to normal per-pod metrics using the \"pods\" source.\nThis is an alpha feature and can be enabled by the HPAContainerMetrics feature flag.\n+optional",
          "$ref": "#/definitions/v2.ContainerResourceMetricSource"
        },
        "external": {
          "description": "external refers to a global metric that is not associated\nwith any Kubernetes object. It allows autoscaling based on information\ncoming from components running outside of cluster\n(for example length of queue in cloud messaging service, or\nQPS from loadbalancer running outside of cluster).\n+optional",
          "$ref": "#/definitions/v2.ExternalMetricSource"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object\n(for example, hits-per-second on an Ingress object).\n+optional",
          "$ref": "#/definitions/v2.ObjectMetricSource"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target\n(for example, transactions-processed-per-second).  The values will be\naveraged together before being compared to the target value.\n+optional",
          "$ref": "#/definitions/v2.PodsMetricSource"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing each pod in the\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\nKubernetes, and have special scaling options on top of those available\nto normal per-pod metrics using the \"pods\" source.\n+optional",
          "$ref": "#/definitions/v2.ResourceMetricSource"
        },
        "type": {
          "type": "string",
          "description": "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\",\n\"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object.\nNote: \"ContainerResource\" type is available on when the feature-gate\nHPAContainerMetrics is enabled"
        }
      }
    },
    "v2.MetricStatus": {
      "type": "object",
      "properties": {
        "containerResource": {
          "description": "container resource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing a single container in each pod in the\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\nKubernetes, and have special scaling options on top of those available\nto normal per-pod metrics using the \"pods\" source.\n+optional",
          "$ref": "#/definitions/v2.ContainerResourceMetricStatus"
        },
        "external": {
          "description": "external refers to a global metric that is not associated\nwith any Kubernetes object. It allows autoscaling based on information\ncoming from components running outside of cluster\n(for example length of queue in cloud messaging service, or\nQPS from loadbalancer running outside of cluster).\n+optional",
          "$ref": "#/definitions/v2.ExternalMetricStatus"
        },
        "object": {
          "description": "object refers to a metric describing a single kubernetes object\n(for example, hits-per-second on an Ingress object).\n+optional",
          "$ref": "#/definitions/v2.ObjectMetricStatus"
        },
        "pods": {
          "description": "pods refers to a metric describing each pod in the current scale target\n(for example, transactions-processed-per-second).  The values will be\naveraged together before being compared to the target value.\n+optional",
          "$ref": "#/definitions/v2.PodsMetricStatus"
        },
        "resource": {
          "description": "resource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing each pod in the\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\nKubernetes, and have special scaling options on top of those available\nto normal per-pod metrics using the \"pods\" source.\n+optional",
          "$ref": "#/definitions/v2.ResourceMetricStatus"
        },
        "type": {
          "type": "string",
          "description": "type is the type of metric source.  It will be one of \"ContainerResource\", \"External\",\n\"Object\", \"Pods\" or \"Resource\", each corresponds to a matching field in the object.\nNote: \"ContainerResource\" type is available on when the feature-gate\nHPAContainerMetrics is enabled"
        }
      }
    },
    "v2.MetricTarget": {
      "type": "object",
      "properties": {
        "averageUtilization": {
          "type": "integer",
          "description": "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type\n+optional"
        },
        "averageValue": {
          "description": "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)\n+optional",
          "$ref": "#/definitions/resource.Quantity"
        },
        "type": {
          "type": "string",
          "description": "type represents whether the metric type is Utilization, Value, or AverageValue"
        },
        "value": {
          "description": "value is the target value of the metric (as a quantity).\n+optional",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v2.MetricValueStatus": {
      "type": "object",
      "properties": {
        "averageUtilization": {
          "type": "integer",
          "description": "currentAverageUtilization is the current value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\n+optional"
        },
        "averageValue": {
          "description": "averageValue is the current value of the average of the\nmetric across all relevant pods (as a quantity)\n+optional",
          "$ref": "#/definitions/resource.Quantity"
        },
        "value": {
          "description": "value is the current value of the metric (as a quantity).\n+optional",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v2.ObjectMetricSource": {
      "type": "object",
      "properties": {
        "describedObject": {
          "description": "describedObject specifies the descriptions of a object,such as kind,name apiVersion",
          "$ref": "#/definitions/v2.CrossVersionObjectReference"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/v2.MetricTarget"
        }
      }
    },
    "v2.ObjectMetricStatus": {
      "type": "object",
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/v2.MetricValueStatus"
        },
        "describedObject": {
          "description": "DescribedObject specifies the descriptions of a object,such as kind,name apiVersion",
          "$ref": "#/definitions/v2.CrossVersionObjectReference"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        }
      }
    },
    "v2.PodsMetricSource": {
      "type": "object",
      "properties": {
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/v2.MetricTarget"
        }
      }
    },
    "v2.PodsMetricStatus": {
      "type": "object",
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/v2.MetricValueStatus"
        },
        "metric": {
          "description": "metric identifies the target metric by name and selector",
          "$ref": "#/definitions/v2.MetricIdentifier"
        }
      }
    },
    "v2.ResourceMetricSource": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name is the name of the resource in question."
        },
        "target": {
          "description": "target specifies the target value for the given metric",
          "$ref": "#/definitions/v2.MetricTarget"
        }
      }
    },
    "v2.ResourceMetricStatus": {
      "type": "object",
      "properties": {
        "current": {
          "description": "current contains the current value for the given metric",
          "$ref": "#/definitions/v2.MetricValueStatus"
        },
        "name": {
          "type": "string",
          "description": "name is the name of the resource in question."
        }
      }
    },
    "webhooks.webhookCreatePayload": {
      "type": "object",
      "properties": {
        "endpointID": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment"
        },
        "registryID": {
          "type": "integer",
          "example": 1,
          "description": "Registry Identifier"
        },
        "resourceID": {
          "type": "string"
        },
        "webhookType": {
          "type": "integer",
          "description": "Type of webhook (1 - service)"
        }
      }
    },
    "webhooks.webhookUpdatePayload": {
      "type": "object",
      "properties": {
        "registryID": {
          "type": "integer",
          "description": "Registry Identifier"
        }
      }
    },
    "endpoints.endpointUpdateRelationsPayload_relations": {
      "type": "object",
      "properties": {
        "edgeGroups": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "EdgeGroup Identifier"
          }
        },
        "group": {
          "type": "integer",
          "example": 1,
          "description": "Environment(Endpoint) group identifier"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "integer",
            "example": 1,
            "description": "Tag identifier"
          }
        }
      }
    },
    "portainer.Endpoint_agent": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "example": "1.0.0"
        }
      }
    },
    "settings.publicSettingsResponse_edge": {
      "type": "object",
      "properties": {
        "CommandInterval": {
          "type": "integer",
          "example": 60,
          "description": "The command list interval for edge agent - used in edge async mode [seconds]"
        },
        "PingInterval": {
          "type": "integer",
          "example": 60,
          "description": "The ping interval for edge agent - used in edge async mode [seconds]"
        },
        "SnapshotInterval": {
          "type": "integer",
          "example": 60,
          "description": "The snapshot interval for edge agent - used in edge async mode [seconds]"
        },
        "checkinInterval": {
          "type": "integer",
          "example": 60,
          "description": "The check in interval for edge agent (in seconds) - used in non async mode [seconds]"
        }
      }
    }
  }
}